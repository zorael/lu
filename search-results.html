<!DOCTYPE html>
<html lang="en">
<head>
        <title>Documentation</title>
	<meta charset="utf-8" />
	<meta content="width=device-width, initial-scale=1" name="viewport" />
        <link href="style.css" rel="stylesheet" />
        <script src="script.js" type="text/javascript"></script>

	
	<link href="search-results.html" rel="prefetch" />
</head>
<body>
	<div id="page-header">
		<div id="logotype">
		<span>Documentation</span>
		<nav>
			<a href="http://dlang.org/">Dlang.org</a>
		</nav>
		</div>

		<form action="search-docs.html" id="search">
			<input name="searchTerm" placeholder="Find a symbol name..." type="search" />
			<input type="submit" value="Go" />
		</form>
	</div>
	<div id="page-body">
		<div id="page-content">
		</div>
		<div id="page-nav">
		</div>
	</div>
	<div id="page-footer">Page generated by <a href="https://github.com/adamdruppe/adrdox">adrdox</a></div>

<script type="text/xml" id="search-index-container">
<adrdox>
<listing>
<decl id="1" type="module"><name>lu.traits</name><desc>&lt;div&gt;&lt;p&gt;Various compile-time traits and cleverness.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.html</link><decl id="2" type="enum"><name>MixinScope</name><desc>&lt;div&gt;&lt;p&gt;The types of scope into which a mixin template may be mixed in.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.MixinScope.html</link></decl><decl id="3" type="mixin template"><name>MixinConstraints</name><desc>&lt;div&gt;&lt;p&gt;Mixes in constraints into another mixin template, to provide static
    guarantees that it is not mixed into a type of scope other than the one specified.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.MixinConstraints.html</link></decl><decl id="4" type="template"><name>CategoryName</name><desc>&lt;div&gt;&lt;p&gt;Provides string representations of the category of a symbol, where such is not
    a fundamental primitive variable but a module, a function, a delegate,
    a class or a struct.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.CategoryName.html</link><decl id="5" type="manifest constant"><name>type</name><desc>&lt;div&gt;&lt;p&gt;String representation of the category type of &lt;tt class=&quot;inline-code&quot;&gt;sym&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.CategoryName.type.html</link></decl><decl id="6" type="manifest constant"><name>name</name><desc>&lt;div&gt;&lt;p&gt;A short name for the symbol &lt;tt class=&quot;inline-code&quot;&gt;sym&lt;/tt&gt; is an alias of.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.CategoryName.name.html</link></decl><decl id="7" type="manifest constant"><name>fqn</name><desc>&lt;div&gt;&lt;p&gt;The fully qualified name for the symbol &lt;tt class=&quot;inline-code&quot;&gt;sym&lt;/tt&gt; is an alias of.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.CategoryName.fqn.html</link></decl></decl><decl id="8" type="template"><name>TakesParams</name><desc>&lt;div&gt;&lt;p&gt;Given a function and a tuple of types, evaluates whether that function could
    be called with that tuple as parameters. Alias version (works on functions,
    not function types.)&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.TakesParams.1.html</link></decl><decl id="9" type="template"><name>TakesParams</name><desc>&lt;div&gt;&lt;p&gt;Given a function and a tuple of types, evaluates whether that function could
    be called with that tuple as parameters. Non-alias version (works on types).&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.TakesParams.2.html</link></decl><decl id="10" type="template"><name>isSerialisable</name><desc>&lt;div&gt;&lt;p&gt;Eponymous template bool of whether a variable can be treated as a mutable
    variable, like a fundamental integral, and thus be serialised.
    Overload that takes a non-type symbol.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.isSerialisable.1.html</link></decl><decl id="11" type="template"><name>isSerialisable</name><desc>&lt;div&gt;&lt;p&gt;Eponymous template bool of whether a variable can be treated as a mutable
    variable, like a fundamental integral, and thus be serialised.
    Overload that takes a type.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.isSerialisable.2.html</link></decl><decl id="12" type="enum"><name>isTrulyString</name><desc>&lt;div&gt;&lt;p&gt;True if a type is &lt;tt class=&quot;inline-code&quot;&gt;string&lt;/tt&gt;, &lt;tt class=&quot;inline-code&quot;&gt;dstring&lt;/tt&gt; or &lt;tt class=&quot;inline-code&quot;&gt;wstring&lt;/tt&gt;; otherwise false.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.isTrulyString.html</link></decl><decl id="13" type="enum"><name>isMerelyArray</name><desc>&lt;div&gt;&lt;p&gt;True if a type is a non-string array; otherwise false.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.isMerelyArray.html</link></decl><decl id="14" type="template"><name>UnqualArray</name><desc>&lt;div&gt;&lt;p&gt;Given an array of qualified elements, aliases itself to one such of
    unqualified elements.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.UnqualArray.1.html</link></decl><decl id="15" type="template"><name>UnqualArray</name><desc>&lt;div&gt;&lt;p&gt;Given an associative array with elements that have a storage class, aliases
    itself to an associative array with elements without the storage classes.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.UnqualArray.2.html</link></decl><decl id="16" type="template"><name>UnqualArray</name><desc>&lt;div&gt;&lt;p&gt;Given an associative array of arrays with a storage class, aliases itself to
    an associative array with array elements without the storage classes.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.UnqualArray.3.html</link></decl><decl id="17" type="enum"><name>isStruct</name><desc>&lt;div&gt;&lt;p&gt;Eponymous template that is &lt;tt class=&quot;inline-code&quot;&gt;true&lt;/tt&gt; if the passed type is a struct.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.isStruct.html</link></decl><decl id="18" type="template"><name>stringofParams</name><desc>&lt;div&gt;&lt;p&gt;Produces a string of the unqualified parameters of the passed function alias.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.stringofParams.html</link></decl><decl id="19" type="enum"><name>isMutableArrayOfImmutables</name><desc>&lt;div&gt;&lt;p&gt;Evaluates whether or not a passed array type is a mutable array of immutable
    elements, such as a string.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.isMutableArrayOfImmutables.html</link></decl><decl id="20" type="enum"><name>udaIndexOf</name><desc>&lt;div&gt;&lt;p&gt;Returns the index of a given UDA, as annotated on a symbol.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.udaIndexOf.html</link></decl><decl id="21" type="enum"><name>stringOfTypeOf</name><desc>&lt;div&gt;&lt;p&gt;The string representation of a type. Non-alias parameter overload.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.stringOfTypeOf.1.html</link></decl><decl id="22" type="enum"><name>stringOfTypeOf</name><desc>&lt;div&gt;&lt;p&gt;The string representation of the type of something. Alias parameter overload.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.stringOfTypeOf.2.html</link></decl><decl id="23" type="template"><name>isImplicitlyConvertibleToSize_t</name><desc>&lt;div&gt;&lt;p&gt;Aliases itself to whether or not a type is implicitly convertible to &lt;tt class=&quot;inline-code&quot;&gt;size_t&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.isImplicitlyConvertibleToSize_t.1.html</link></decl><decl id="24" type="template"><name>isImplicitlyConvertibleToSize_t</name><desc>&lt;div&gt;&lt;p&gt;Aliases itself to whether or not a symbol is of a type that is implicitly
    convertible to &lt;tt class=&quot;inline-code&quot;&gt;size_t&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.isImplicitlyConvertibleToSize_t.2.html</link></decl><decl id="25" type="template"><name>isEnum</name><desc>&lt;div&gt;&lt;p&gt;Aliases itself to whether or not a type is an enum.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.isEnum.1.html</link></decl><decl id="26" type="template"><name>isEnum</name><desc>&lt;div&gt;&lt;p&gt;Aliases itself to whether or not a symbol is of a type is an enum.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.isEnum.2.html</link></decl><decl id="27" type="template"><name>allOfSameType</name><desc>&lt;div&gt;&lt;p&gt;Aliases itself to whether or not all passed values are of the same type.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.allOfSameType.html</link></decl></decl><decl id="28" type="module"><name>lu.deltastrings</name><desc>&lt;div&gt;&lt;p&gt;Functions used to generate strings of statements describing the differences
    (or delta) between two instances of a struct or class of the same type.
    They can be either assignment statements or assert statements.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.deltastrings.html</link><decl id="29" type="function"><name>putDelta</name><desc>&lt;div&gt;&lt;p&gt;Constructs statement lines for each changed field (or the delta) between two
    instances of a struct and stores them into a passed output sink.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.deltastrings.putDelta.html</link></decl><decl id="30" type="alias"><name>formatDeltaInto</name><desc>&lt;div&gt;&lt;p&gt;Deprecated alias of &lt;tt class=&quot;inline-code&quot;&gt;putDelta&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.deltastrings.formatDeltaInto.html</link></decl></decl><decl id="31" type="module"><name>lu</name><desc>&lt;div&gt;&lt;p&gt;&lt;b&gt;lu&lt;/b&gt; is a general-purpose library for the D programming language.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.html</link><decl id="32" type="module"><name>lu.traits</name><desc>&lt;div&gt;&lt;p&gt;Various compile-time traits and cleverness.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.html</link><decl id="33" type="enum"><name>MixinScope</name><desc>&lt;div&gt;&lt;p&gt;The types of scope into which a mixin template may be mixed in.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.MixinScope.html</link></decl><decl id="34" type="mixin template"><name>MixinConstraints</name><desc>&lt;div&gt;&lt;p&gt;Mixes in constraints into another mixin template, to provide static
    guarantees that it is not mixed into a type of scope other than the one specified.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.MixinConstraints.html</link></decl><decl id="35" type="template"><name>CategoryName</name><desc>&lt;div&gt;&lt;p&gt;Provides string representations of the category of a symbol, where such is not
    a fundamental primitive variable but a module, a function, a delegate,
    a class or a struct.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.CategoryName.html</link><decl id="36" type="manifest constant"><name>type</name><desc>&lt;div&gt;&lt;p&gt;String representation of the category type of &lt;tt class=&quot;inline-code&quot;&gt;sym&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.CategoryName.type.html</link></decl><decl id="37" type="manifest constant"><name>name</name><desc>&lt;div&gt;&lt;p&gt;A short name for the symbol &lt;tt class=&quot;inline-code&quot;&gt;sym&lt;/tt&gt; is an alias of.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.CategoryName.name.html</link></decl><decl id="38" type="manifest constant"><name>fqn</name><desc>&lt;div&gt;&lt;p&gt;The fully qualified name for the symbol &lt;tt class=&quot;inline-code&quot;&gt;sym&lt;/tt&gt; is an alias of.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.CategoryName.fqn.html</link></decl></decl><decl id="39" type="template"><name>TakesParams</name><desc>&lt;div&gt;&lt;p&gt;Given a function and a tuple of types, evaluates whether that function could
    be called with that tuple as parameters. Alias version (works on functions,
    not function types.)&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.TakesParams.1.html</link></decl><decl id="40" type="template"><name>TakesParams</name><desc>&lt;div&gt;&lt;p&gt;Given a function and a tuple of types, evaluates whether that function could
    be called with that tuple as parameters. Non-alias version (works on types).&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.TakesParams.2.html</link></decl><decl id="41" type="template"><name>isSerialisable</name><desc>&lt;div&gt;&lt;p&gt;Eponymous template bool of whether a variable can be treated as a mutable
    variable, like a fundamental integral, and thus be serialised.
    Overload that takes a non-type symbol.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.isSerialisable.1.html</link></decl><decl id="42" type="template"><name>isSerialisable</name><desc>&lt;div&gt;&lt;p&gt;Eponymous template bool of whether a variable can be treated as a mutable
    variable, like a fundamental integral, and thus be serialised.
    Overload that takes a type.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.isSerialisable.2.html</link></decl><decl id="43" type="enum"><name>isTrulyString</name><desc>&lt;div&gt;&lt;p&gt;True if a type is &lt;tt class=&quot;inline-code&quot;&gt;string&lt;/tt&gt;, &lt;tt class=&quot;inline-code&quot;&gt;dstring&lt;/tt&gt; or &lt;tt class=&quot;inline-code&quot;&gt;wstring&lt;/tt&gt;; otherwise false.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.isTrulyString.html</link></decl><decl id="44" type="enum"><name>isMerelyArray</name><desc>&lt;div&gt;&lt;p&gt;True if a type is a non-string array; otherwise false.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.isMerelyArray.html</link></decl><decl id="45" type="template"><name>UnqualArray</name><desc>&lt;div&gt;&lt;p&gt;Given an array of qualified elements, aliases itself to one such of
    unqualified elements.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.UnqualArray.1.html</link></decl><decl id="46" type="template"><name>UnqualArray</name><desc>&lt;div&gt;&lt;p&gt;Given an associative array with elements that have a storage class, aliases
    itself to an associative array with elements without the storage classes.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.UnqualArray.2.html</link></decl><decl id="47" type="template"><name>UnqualArray</name><desc>&lt;div&gt;&lt;p&gt;Given an associative array of arrays with a storage class, aliases itself to
    an associative array with array elements without the storage classes.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.UnqualArray.3.html</link></decl><decl id="48" type="enum"><name>isStruct</name><desc>&lt;div&gt;&lt;p&gt;Eponymous template that is &lt;tt class=&quot;inline-code&quot;&gt;true&lt;/tt&gt; if the passed type is a struct.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.isStruct.html</link></decl><decl id="49" type="template"><name>stringofParams</name><desc>&lt;div&gt;&lt;p&gt;Produces a string of the unqualified parameters of the passed function alias.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.stringofParams.html</link></decl><decl id="50" type="enum"><name>isMutableArrayOfImmutables</name><desc>&lt;div&gt;&lt;p&gt;Evaluates whether or not a passed array type is a mutable array of immutable
    elements, such as a string.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.isMutableArrayOfImmutables.html</link></decl><decl id="51" type="enum"><name>udaIndexOf</name><desc>&lt;div&gt;&lt;p&gt;Returns the index of a given UDA, as annotated on a symbol.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.udaIndexOf.html</link></decl><decl id="52" type="enum"><name>stringOfTypeOf</name><desc>&lt;div&gt;&lt;p&gt;The string representation of a type. Non-alias parameter overload.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.stringOfTypeOf.1.html</link></decl><decl id="53" type="enum"><name>stringOfTypeOf</name><desc>&lt;div&gt;&lt;p&gt;The string representation of the type of something. Alias parameter overload.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.stringOfTypeOf.2.html</link></decl><decl id="54" type="template"><name>isImplicitlyConvertibleToSize_t</name><desc>&lt;div&gt;&lt;p&gt;Aliases itself to whether or not a type is implicitly convertible to &lt;tt class=&quot;inline-code&quot;&gt;size_t&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.isImplicitlyConvertibleToSize_t.1.html</link></decl><decl id="55" type="template"><name>isImplicitlyConvertibleToSize_t</name><desc>&lt;div&gt;&lt;p&gt;Aliases itself to whether or not a symbol is of a type that is implicitly
    convertible to &lt;tt class=&quot;inline-code&quot;&gt;size_t&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.isImplicitlyConvertibleToSize_t.2.html</link></decl><decl id="56" type="template"><name>isEnum</name><desc>&lt;div&gt;&lt;p&gt;Aliases itself to whether or not a type is an enum.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.isEnum.1.html</link></decl><decl id="57" type="template"><name>isEnum</name><desc>&lt;div&gt;&lt;p&gt;Aliases itself to whether or not a symbol is of a type is an enum.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.isEnum.2.html</link></decl><decl id="58" type="template"><name>allOfSameType</name><desc>&lt;div&gt;&lt;p&gt;Aliases itself to whether or not all passed values are of the same type.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.traits.allOfSameType.html</link></decl></decl><decl id="59" type="module"><name>lu.deltastrings</name><desc>&lt;div&gt;&lt;p&gt;Functions used to generate strings of statements describing the differences
    (or delta) between two instances of a struct or class of the same type.
    They can be either assignment statements or assert statements.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.deltastrings.html</link><decl id="60" type="function"><name>putDelta</name><desc>&lt;div&gt;&lt;p&gt;Constructs statement lines for each changed field (or the delta) between two
    instances of a struct and stores them into a passed output sink.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.deltastrings.putDelta.html</link></decl><decl id="61" type="alias"><name>formatDeltaInto</name><desc>&lt;div&gt;&lt;p&gt;Deprecated alias of &lt;tt class=&quot;inline-code&quot;&gt;putDelta&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.deltastrings.formatDeltaInto.html</link></decl></decl><decl id="62" type="module"><name>lu.array</name><desc>&lt;div&gt;&lt;p&gt;Simple array utilities.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.html</link><decl id="63" type="function"><name>uniqueKey</name><desc>&lt;div&gt;&lt;p&gt;Returns a unique key for the passed associative array. Reserves the key by
    assigning it a value.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.uniqueKey.html</link></decl><decl id="64" type="function"><name>zero</name><desc>&lt;div&gt;&lt;p&gt;Zeroes out the contents of an &lt;a class=&quot;xref&quot; href=&quot;std.array.Appender.html&quot;&gt;Appender&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.zero.html</link></decl><decl id="65" type="function"><name>truthTable</name><desc>&lt;div&gt;&lt;p&gt;Generates a truth table from a list of runtime numbers.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.truthTable.1.html</link></decl><decl id="66" type="function"><name>truthTable</name><desc>&lt;div&gt;&lt;p&gt;Generates a truth table from a list of runtime enum values.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.truthTable.2.html</link></decl><decl id="67" type="function"><name>truthTable</name><desc>&lt;div&gt;&lt;p&gt;Generates a static truth table from a list of compile-time numbers.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.truthTable.3.html</link></decl><decl id="68" type="function"><name>truthTable</name><desc>&lt;div&gt;&lt;p&gt;Generates a static truth table from a list of compile-time enum values.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.truthTable.4.html</link></decl><decl id="69" type="class"><name>ArrayException</name><desc>&lt;div&gt;&lt;p&gt;Exception, to be thrown when there was an array-related error.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.ArrayException.html</link><decl id="70" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.array.ArrayException.html&quot;&gt;ArrayException&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.ArrayException.this.html</link></decl></decl><decl id="71" type="function"><name>pruneAA</name><desc>&lt;div&gt;&lt;p&gt;Iterates an associative array and deletes invalid entries, either if the value
    is in a default &lt;tt class=&quot;inline-code&quot;&gt;.init&lt;/tt&gt; state or as per the optionally passed predicate.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.pruneAA.html</link></decl><decl id="72" type="function"><name>countUntilLastOccurrenceOf</name><desc>&lt;div&gt;&lt;p&gt;Finds the index of the last occurrence of a needle in a haystack.
    The needle may be a single element (character) or an array of the same type
    as the haystack.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.countUntilLastOccurrenceOf.html</link></decl><decl id="73" type="function"><name>countUntilLastMatchOf</name><desc>&lt;div&gt;&lt;p&gt;Finds the index of the last match of a predicate in a haystack. The predicate
    is evaluated against each element.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.countUntilLastMatchOf.html</link></decl></decl><decl id="74" type="module"><name>lu.common</name><desc>&lt;div&gt;&lt;p&gt;Compatibility module publicly importing symbols from &lt;a class=&quot;xref&quot; href=&quot;lu.misc.html&quot;&gt;lu.misc&lt;/a&gt;.
    Import symbols directly from &lt;a class=&quot;xref&quot; href=&quot;lu.misc.html&quot;&gt;lu.misc&lt;/a&gt; instead.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.common.html</link></decl><decl id="75" type="module"><name>lu.semver</name><desc>&lt;div&gt;&lt;p&gt;SemVer information about the current release.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.semver.html</link><decl id="76" type="enum"><name>LuSemVer</name><desc>&lt;div&gt;&lt;p&gt;SemVer versioning of this build.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.semver.LuSemVer.html</link></decl><decl id="77" type="manifest constant"><name>LuSemVerPrerelease</name><desc>&lt;div&gt;&lt;p&gt;Pre-release SemVer subversion of this build.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.semver.LuSemVerPrerelease.html</link></decl></decl><decl id="78" type="module"><name>lu.numeric</name><desc>&lt;div&gt;&lt;p&gt;Functions and templates that do calculations or other numeric manipulation,
    in some way or another.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.numeric.html</link><decl id="79" type="function"><name>getMultipleOf</name><desc>&lt;div&gt;&lt;p&gt;Given a number, calculate the largest multiple of &lt;tt class=&quot;inline-code&quot;&gt;n&lt;/tt&gt; needed to reach that number.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.numeric.getMultipleOf.html</link></decl></decl><decl id="80" type="module"><name>lu.objmanip</name><desc>&lt;div&gt;&lt;p&gt;This module contains functions that in some way or another manipulates
    struct and class instances, as well as (associative) arrays.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.objmanip.html</link><decl id="81" type="function"><name>setMemberByName</name><desc>&lt;div&gt;&lt;p&gt;Given a struct/class object, sets one of its members by its string name to a
    specified value. Overload that takes the value as a string and tries to
    convert it into the target type.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.objmanip.setMemberByName.1.html</link></decl><decl id="82" type="function"><name>setMemberByName</name><desc>&lt;div&gt;&lt;p&gt;Given a struct/class object, sets one of its members by its string name to a
    specified value. Overload that takes a value of the same type as the target
    member, rather than a string to convert. Integer promotion applies.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.objmanip.setMemberByName.2.html</link></decl><decl id="83" type="class"><name>SetMemberException</name><desc>&lt;div&gt;&lt;p&gt;Exception, to be thrown when &lt;a class=&quot;xref&quot; href=&quot;lu.objmanip.setMemberByName.2.html&quot;&gt;setMemberByName&lt;/a&gt; fails for some given reason.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.objmanip.SetMemberException.html</link><decl id="84" type="variable"><name>typeName</name><desc>&lt;div&gt;&lt;p&gt;Name of type that was attempted to set the member of.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.objmanip.SetMemberException.typeName.html</link></decl><decl id="85" type="variable"><name>memberToSet</name><desc>&lt;div&gt;&lt;p&gt;Name of the member that was attempted to set.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.objmanip.SetMemberException.memberToSet.html</link></decl><decl id="86" type="variable"><name>valueToSet</name><desc>&lt;div&gt;&lt;p&gt;String representation of the value that was attempted to assign.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.objmanip.SetMemberException.valueToSet.html</link></decl><decl id="87" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.objmanip.SetMemberException.html&quot;&gt;SetMemberException&lt;/a&gt;, without attaching anything.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.objmanip.SetMemberException.this.1.html</link></decl><decl id="88" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.objmanip.SetMemberException.html&quot;&gt;SetMemberException&lt;/a&gt;, attaching extra set-member information.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.objmanip.SetMemberException.this.2.html</link></decl></decl><decl id="89" type="function"><name>replaceMembers</name><desc>&lt;div&gt;&lt;p&gt;Inspects a passed struct or class for members whose values match that of the
    passed &lt;tt class=&quot;inline-code&quot;&gt;token&lt;/tt&gt;. Matches members are set to a replacement value, which is
    an optional parameter that defaults to the &lt;tt class=&quot;inline-code&quot;&gt;.init&lt;/tt&gt; value of the token's type.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.objmanip.replaceMembers.html</link></decl></decl><decl id="90" type="module"><name>lu.misc</name><desc>&lt;div&gt;&lt;p&gt;Things that don't have a better home yet.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.html</link><decl id="91" type="enum"><name>Next</name><desc>&lt;div&gt;&lt;p&gt;Enum of flags carrying the meaning of &amp;quot;what to do next&amp;quot;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.Next.html</link></decl><decl id="92" type="class"><name>ReturnValueException</name><desc>&lt;div&gt;&lt;p&gt;Exception, to be thrown when an executed command returns an error value.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.ReturnValueException.html</link><decl id="93" type="variable"><name>command</name><desc>&lt;div&gt;&lt;p&gt;The command run.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.ReturnValueException.command.html</link></decl><decl id="94" type="variable"><name>retval</name><desc>&lt;div&gt;&lt;p&gt;The value returned.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.ReturnValueException.retval.html</link></decl><decl id="95" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.misc.ReturnValueException.html&quot;&gt;ReturnValueException&lt;/a&gt;, without attaching anything.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.ReturnValueException.this.1.html</link></decl><decl id="96" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.misc.ReturnValueException.html&quot;&gt;ReturnValueException&lt;/a&gt;, attaching a command.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.ReturnValueException.this.2.html</link></decl><decl id="97" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.misc.ReturnValueException.html&quot;&gt;ReturnValueException&lt;/a&gt;, attaching a command and a returned value.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.ReturnValueException.this.3.html</link></decl></decl><decl id="98" type="class"><name>FileExistsException</name><desc>&lt;div&gt;&lt;p&gt;Exception, to be thrown when attempting to create a file or directory and
    finding that one already exists with the same name.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.FileExistsException.html</link><decl id="99" type="variable"><name>filename</name><desc>&lt;div&gt;&lt;p&gt;The name of the file.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.FileExistsException.filename.html</link></decl><decl id="100" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.misc.FileExistsException.html&quot;&gt;FileExistsException&lt;/a&gt;, without attaching a filename.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.FileExistsException.this.1.html</link></decl><decl id="101" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.misc.FileExistsException.html&quot;&gt;FileExistsException&lt;/a&gt;, attaching a filename.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.FileExistsException.this.2.html</link></decl></decl><decl id="102" type="class"><name>FileTypeMismatchException</name><desc>&lt;div&gt;&lt;p&gt;Exception, to be thrown when attempting to access a file or directory and
    finding that something with the that name exists, but is of an unexpected type.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.FileTypeMismatchException.html</link><decl id="103" type="variable"><name>filename</name><desc>&lt;div&gt;&lt;p&gt;The filename of the file in question.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.FileTypeMismatchException.filename.html</link></decl><decl id="104" type="variable"><name>attrs</name><desc>&lt;div&gt;&lt;p&gt;File attributes.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.FileTypeMismatchException.attrs.html</link></decl><decl id="105" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.misc.FileTypeMismatchException.html&quot;&gt;FileTypeMismatchException&lt;/a&gt;, without embedding a filename.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.FileTypeMismatchException.this.1.html</link></decl><decl id="106" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.misc.FileTypeMismatchException.html&quot;&gt;FileTypeMismatchException&lt;/a&gt;, embedding a filename.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.FileTypeMismatchException.this.2.html</link></decl></decl><decl id="107" type="function"><name>sharedDomains</name><desc>&lt;div&gt;&lt;p&gt;Calculates how many dot-separated domains two strings share.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.sharedDomains.html</link></decl></decl><decl id="108" type="module"><name>lu.assert_</name><desc>&lt;div&gt;&lt;p&gt;Assertion helpers.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.assert_.html</link><decl id="109" type="function"><name>assertMultilineEquals</name><desc>&lt;div&gt;&lt;p&gt;Asserts that two multiple-line strings are equal, with a more detailed error
    message than the yes/no of the built-in &lt;tt class=&quot;inline-code&quot;&gt;assert()&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.assert_.assertMultilineEquals.html</link></decl></decl><decl id="110" type="module"><name>lu.string</name><desc>&lt;div&gt;&lt;p&gt;String manipulation functions.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.html</link><decl id="111" type="function"><name>advancePast</name><desc>&lt;div&gt;&lt;p&gt;Given a reference to some string, finds the supplied needle token in it, returns the
    string up to that point, and advances the passed ref string to after the token.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.advancePast.html</link></decl><decl id="112" type="class"><name>AdvanceException</name><desc>&lt;div&gt;&lt;p&gt;Exception, to be thrown when a call to &lt;a class=&quot;xref&quot; href=&quot;lu.string.advancePast.html&quot;&gt;advancePast&lt;/a&gt; went wrong.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceException.html</link><decl id="113" type="function"><name>haystack</name><desc>&lt;div&gt;&lt;p&gt;Returns a string of the original haystack the call to &lt;a class=&quot;xref&quot; href=&quot;lu.string.advancePast.html&quot;&gt;advancePast&lt;/a&gt; was operating on.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceException.haystack.html</link></decl><decl id="114" type="function"><name>needle</name><desc>&lt;div&gt;&lt;p&gt;Returns a string of the original needle the call to &lt;a class=&quot;xref&quot; href=&quot;lu.string.advancePast.html&quot;&gt;advancePast&lt;/a&gt; was operating on.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceException.needle.html</link></decl><decl id="115" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.string.AdvanceExceptionImpl.html&quot;&gt;AdvanceExceptionImpl&lt;/a&gt;, without attaching anything.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceException.this.html</link></decl></decl><decl id="116" type="class"><name>AdvanceExceptionImpl</name><desc>&lt;div&gt;&lt;p&gt;Exception, to be thrown when a call to &lt;a class=&quot;xref&quot; href=&quot;lu.string.advancePast.html&quot;&gt;advancePast&lt;/a&gt; went wrong.
    This is the templated implementation, so that we can support more than one
    kind of needle and haystack combination.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceExceptionImpl.html</link><decl id="117" type="variable"><name>_haystack</name><desc>&lt;div&gt;&lt;p&gt;Raw haystack that &lt;tt class=&quot;inline-code&quot;&gt;haystack&lt;/tt&gt; converts to string and returns.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceExceptionImpl._haystack.html</link></decl><decl id="118" type="variable"><name>_needle</name><desc>&lt;div&gt;&lt;p&gt;Raw needle that &lt;tt class=&quot;inline-code&quot;&gt;needle&lt;/tt&gt; converts to string and returns.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceExceptionImpl._needle.html</link></decl><decl id="119" type="function"><name>haystack</name><desc>&lt;div&gt;&lt;p&gt;Returns a string of the original needle the call to &lt;tt class=&quot;inline-code&quot;&gt;advancePast&lt;/tt&gt; was operating on.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceExceptionImpl.haystack.html</link></decl><decl id="120" type="function"><name>needle</name><desc>&lt;div&gt;&lt;p&gt;Returns a string of the original needle the call to &lt;tt class=&quot;inline-code&quot;&gt;advancePast&lt;/tt&gt; was operating on.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceExceptionImpl.needle.html</link></decl><decl id="121" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;tt class=&quot;inline-code&quot;&gt;AdvanceExceptionImpl&lt;/tt&gt;, without attaching anything.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceExceptionImpl.this.1.html</link></decl><decl id="122" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;tt class=&quot;inline-code&quot;&gt;AdvanceExceptionImpl&lt;/tt&gt;, attaching a command.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceExceptionImpl.this.2.html</link></decl></decl><decl id="123" type="function"><name>plurality</name><desc>&lt;div&gt;&lt;p&gt;Returns the singular or plural form of a word based on a numeric value.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.plurality.html</link></decl><decl id="124" type="function"><name>unenclosed</name><desc>&lt;div&gt;&lt;p&gt;Removes paired preceding and trailing tokens around a string line.
    Assumes ASCII.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.unenclosed.html</link></decl><decl id="125" type="function"><name>unquoted</name><desc>&lt;div&gt;&lt;p&gt;Removes paired preceding and trailing double quotes, unquoting a word.
    Assumes ASCII.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.unquoted.html</link></decl><decl id="126" type="function"><name>unsinglequoted</name><desc>&lt;div&gt;&lt;p&gt;Removes paired preceding and trailing single quotes around a line.
    Assumes ASCII.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.unsinglequoted.html</link></decl><decl id="127" type="function"><name>stripSuffix</name><desc>&lt;div&gt;&lt;p&gt;Strips the supplied string from the end of a string.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.stripSuffix.html</link></decl><decl id="128" type="function"><name>tabs</name><desc>&lt;div&gt;&lt;p&gt;Returns a range of *spaces* equal to that of &lt;tt class=&quot;inline-code&quot;&gt;num&lt;/tt&gt; tabs (&lt;tt class=&quot;inline-code&quot;&gt;'\t'&lt;/tt&gt;).&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.tabs.html</link></decl><decl id="129" type="function"><name>indentInto</name><desc>&lt;div&gt;&lt;p&gt;Indents lines in a string into an output range sink with the supplied number
    of space-based tabs.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.indentInto.html</link></decl><decl id="130" type="function"><name>indent</name><desc>&lt;div&gt;&lt;p&gt;Indents lines in a string with the supplied number of space-based tabs.
    Returns a newly-allocated string.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.indent.html</link></decl><decl id="131" type="function"><name>strippedRight</name><desc>&lt;div&gt;&lt;p&gt;Returns a slice of the passed string with any trailing whitespace and/or
    linebreaks sliced off. Overload that implicitly strips &lt;tt class=&quot;inline-code&quot;&gt;&amp;quot; \n\r\t&amp;quot;&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.strippedRight.1.html</link></decl><decl id="132" type="function"><name>strippedRight</name><desc>&lt;div&gt;&lt;p&gt;Returns a slice of the passed string with any trailing passed characters.
    Implementation template capable of handling both individual characters and
    string of tokens to strip.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.strippedRight.2.html</link></decl><decl id="133" type="function"><name>strippedLeft</name><desc>&lt;div&gt;&lt;p&gt;Returns a slice of the passed string with any preceding whitespace and/or
    linebreaks sliced off. Overload that implicitly strips &lt;tt class=&quot;inline-code&quot;&gt;&amp;quot; \n\r\t&amp;quot;&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.strippedLeft.1.html</link></decl><decl id="134" type="function"><name>strippedLeft</name><desc>&lt;div&gt;&lt;p&gt;Returns a slice of the passed string with any preceding passed characters
    sliced off. Implementation capable of handling both individual characters
    and strings of tokens to strip.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.strippedLeft.2.html</link></decl><decl id="135" type="function"><name>stripped</name><desc>&lt;div&gt;&lt;p&gt;Returns a slice of the passed string with any preceding or trailing
    whitespace or linebreaks sliced off both ends. Overload that implicitly
    strips &lt;tt class=&quot;inline-code&quot;&gt;&amp;quot; \n\r\t&amp;quot;&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.stripped.1.html</link></decl><decl id="136" type="function"><name>stripped</name><desc>&lt;div&gt;&lt;p&gt;Returns a slice of the passed string with any preceding or trailing
    passed characters sliced off. Implementation template capable of handling both
    individual characters and strings of tokens to strip.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.stripped.2.html</link></decl><decl id="137" type="function"><name>encode64</name><desc>&lt;div&gt;&lt;p&gt;Base64-encodes a string.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.encode64.html</link></decl><decl id="138" type="function"><name>decode64</name><desc>&lt;div&gt;&lt;p&gt;Base64-decodes a string.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.decode64.html</link></decl><decl id="139" type="function"><name>splitLineAtPosition</name><desc>&lt;div&gt;&lt;p&gt;Splits a string with on boundary as delimited by a supplied separator, into
    one or more more lines not longer than the passed maximum length.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.splitLineAtPosition.html</link></decl><decl id="140" type="function"><name>escapeControlCharacters</name><desc>&lt;div&gt;&lt;p&gt;Replaces the control characters &lt;tt class=&quot;inline-code&quot;&gt;'\n'&lt;/tt&gt;, &lt;tt class=&quot;inline-code&quot;&gt;'\t'&lt;/tt&gt;, &lt;tt class=&quot;inline-code&quot;&gt;'\r'&lt;/tt&gt; and &lt;tt class=&quot;inline-code&quot;&gt;'\0'&lt;/tt&gt; in a string
    with the escaped &lt;tt class=&quot;inline-code&quot;&gt;&amp;quot;\\n&amp;quot;&lt;/tt&gt;, &lt;tt class=&quot;inline-code&quot;&gt;&amp;quot;\\t&amp;quot;&lt;/tt&gt;, &lt;tt class=&quot;inline-code&quot;&gt;&amp;quot;\\r&amp;quot;&lt;/tt&gt; and &lt;tt class=&quot;inline-code&quot;&gt;&amp;quot;\\0&amp;quot;&lt;/tt&gt;.
    Does not allocate a new string if there was nothing to escape.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.escapeControlCharacters.html</link></decl><decl id="141" type="function"><name>removeControlCharacters</name><desc>&lt;div&gt;&lt;p&gt;Removes the control characters &lt;tt class=&quot;inline-code&quot;&gt;'\n'&lt;/tt&gt;, &lt;tt class=&quot;inline-code&quot;&gt;'\t'&lt;/tt&gt;, &lt;tt class=&quot;inline-code&quot;&gt;'\r'&lt;/tt&gt; and &lt;tt class=&quot;inline-code&quot;&gt;'\0'&lt;/tt&gt; from a string.
    Does not allocate a new string if there was nothing to remove.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.removeControlCharacters.html</link></decl><decl id="142" type="enum"><name>SplitResults</name><desc>&lt;div&gt;&lt;p&gt;The result of a call to &lt;a class=&quot;xref&quot; href=&quot;lu.string.splitInto.2.html&quot;&gt;splitInto&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.SplitResults.html</link></decl><decl id="143" type="function"><name>splitInto</name><desc>&lt;div&gt;&lt;p&gt;Splits a string by a passed separator and assigns the delimited words to the
    passed ref strings.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.splitInto.1.html</link></decl><decl id="144" type="function"><name>splitInto</name><desc>&lt;div&gt;&lt;p&gt;Splits a string by a passed separator and assign the delimited words to the
    passed ref strings. Overload that stores overflow strings into a passed array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.splitInto.2.html</link></decl><decl id="145" type="function"><name>splitWithQuotes</name><desc>&lt;div&gt;&lt;p&gt;Splits a string into an array of strings by whitespace, but honours quotes.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.splitWithQuotes.html</link></decl><decl id="146" type="function"><name>replaceFromAA</name><desc>&lt;div&gt;&lt;p&gt;Replaces space-separated words that begin with a token character in a
    string that match keys in a supplied associative array.
    The associative array values must be of some callable type of function or
    delegate returning strings.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.replaceFromAA.html</link></decl></decl><decl id="147" type="module"><name>lu.container</name><desc>&lt;div&gt;&lt;p&gt;Containers of varying quality.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.html</link><decl id="148" type="struct"><name>Buffer</name><desc>&lt;div&gt;&lt;p&gt;Simple buffer/queue for storing and fetching items of any type &lt;tt class=&quot;inline-code&quot;&gt;T&lt;/tt&gt;.
    Does not use manual memory allocation.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.html</link><decl id="149" type="manifest constant"><name>growthFactor</name><desc>&lt;div&gt;&lt;p&gt;By how much to grow the buffer when we reach the end of it.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.growthFactor.html</link></decl><decl id="150" type="variable"><name>buf</name><desc>&lt;div&gt;&lt;p&gt;Internal buffer dynamic array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.buf.1.html</link></decl><decl id="151" type="variable"><name>bufferSize</name><desc>&lt;div&gt;&lt;p&gt;Variable buffer size.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.bufferSize.1.html</link></decl><decl id="152" type="variable"><name>buf</name><desc>&lt;div&gt;&lt;p&gt;Internal buffer static array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.buf.2.html</link></decl><decl id="153" type="alias"><name>bufferSize</name><desc>&lt;div&gt;&lt;p&gt;Static buffer size.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.bufferSize.2.html</link></decl><decl id="154" type="variable"><name>pos</name><desc>&lt;div&gt;&lt;p&gt;Current position in the array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.pos.html</link></decl><decl id="155" type="variable"><name>end</name><desc>&lt;div&gt;&lt;p&gt;Position of last entry in the array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.end.html</link></decl><decl id="156" type="function"><name>put</name><desc>&lt;div&gt;&lt;p&gt;Append an item to the end of the buffer.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.put.1.html</link></decl><decl id="157" type="function"><name>put</name><desc>&lt;div&gt;&lt;p&gt;Append an item to the end of the buffer.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.put.2.html</link></decl><decl id="158" type="function"><name>reserve</name><desc>&lt;div&gt;&lt;p&gt;Reserves enough room for the specified number of elements. If there
            is already enough room, nothing is done. Otherwise the buffer is grown.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.reserve.html</link></decl><decl id="159" type="function"><name>opOpAssign</name><desc>&lt;div&gt;&lt;p&gt;Implements &lt;tt class=&quot;inline-code&quot;&gt;buf ~= someT&lt;/tt&gt; (appending) by wrapping &lt;tt class=&quot;inline-code&quot;&gt;put&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.opOpAssign.html</link></decl><decl id="160" type="function"><name>front</name><desc>&lt;div&gt;&lt;p&gt;Fetches the item at the current position of the buffer.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.front.html</link></decl><decl id="161" type="function"><name>popFront</name><desc>&lt;div&gt;&lt;p&gt;Advances the current position to the next item in the buffer.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.popFront.html</link></decl><decl id="162" type="function"><name>length</name><desc>&lt;div&gt;&lt;p&gt;Returns what amounts to the current length of the buffer; the distance
        between the current position &lt;tt class=&quot;inline-code&quot;&gt;pos&lt;/tt&gt; and the last element &lt;tt class=&quot;inline-code&quot;&gt;end&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.length.html</link></decl><decl id="163" type="function"><name>empty</name><desc>&lt;div&gt;&lt;p&gt;Returns whether or not the container is considered empty.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.empty.html</link></decl><decl id="164" type="function"><name>reset</name><desc>&lt;div&gt;&lt;p&gt;Resets the array positions, effectively soft-emptying the buffer.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.reset.html</link></decl><decl id="165" type="function"><name>clear</name><desc>&lt;div&gt;&lt;p&gt;Zeroes out the buffer's elements, getting rid of old contents.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.clear.html</link></decl></decl><decl id="166" type="struct"><name>CircularBuffer</name><desc>&lt;div&gt;&lt;p&gt;Simple circular-ish buffer for storing items of type &lt;tt class=&quot;inline-code&quot;&gt;T&lt;/tt&gt; that discards elements
    when the maximum size is reached. Does not use manual memory allocation.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.html</link><decl id="167" type="variable"><name>buf</name><desc>&lt;div&gt;&lt;p&gt;Internal buffer dynamic array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.buf.1.html</link></decl><decl id="168" type="variable"><name>buf</name><desc>&lt;div&gt;&lt;p&gt;Internal buffer static array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.buf.2.html</link></decl><decl id="169" type="variable"><name>head</name><desc>&lt;div&gt;&lt;p&gt;Head position in the internal buffer.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.head.html</link></decl><decl id="170" type="variable"><name>tail</name><desc>&lt;div&gt;&lt;p&gt;Tail position in the internal buffer.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.tail.html</link></decl><decl id="171" type="variable"><name>caughtUp</name><desc>&lt;div&gt;&lt;p&gt;Whether or not &lt;a class=&quot;xref&quot; href=&quot;lu.container.CircularBuffer.head.html&quot;&gt;head&lt;/a&gt; and &lt;a class=&quot;xref&quot; href=&quot;lu.container.CircularBuffer.tail.html&quot;&gt;tail&lt;/a&gt; point to the same position in the
        context of a circular array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.caughtUp.html</link></decl><decl id="172" type="variable"><name>initialised</name><desc>&lt;div&gt;&lt;p&gt;Whether or not at least one element has been added.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.initialised.html</link></decl><decl id="173" type="function"><name>front</name><desc>&lt;div&gt;&lt;p&gt;Returns the front element.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.front.html</link></decl><decl id="174" type="function"><name>put</name><desc>&lt;div&gt;&lt;p&gt;Append an item to the buffer.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.put.html</link></decl><decl id="175" type="function"><name>popFront</name><desc>&lt;div&gt;&lt;p&gt;Advances the current position to the next item in the buffer.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.popFront.html</link></decl><decl id="176" type="function"><name>resize</name><desc>&lt;div&gt;&lt;p&gt;Resizes the internal buffer to a specified size.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.resize.html</link></decl><decl id="177" type="function"><name>opOpAssign</name><desc>&lt;div&gt;&lt;p&gt;Implements &lt;tt class=&quot;inline-code&quot;&gt;buf ~= someT&lt;/tt&gt; (appending) by wrapping &lt;tt class=&quot;inline-code&quot;&gt;put&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.opOpAssign.html</link></decl><decl id="178" type="function"><name>size</name><desc>&lt;div&gt;&lt;p&gt;Returns the size of the internal buffer.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.size.html</link></decl><decl id="179" type="function"><name>empty</name><desc>&lt;div&gt;&lt;p&gt;Returns whether or not the container is considered empty.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.empty.html</link></decl><decl id="180" type="function"><name>save</name><desc>&lt;div&gt;&lt;p&gt;Implements Range &lt;tt class=&quot;inline-code&quot;&gt;save&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.save.html</link></decl><decl id="181" type="function"><name>dup</name><desc>&lt;div&gt;&lt;p&gt;Makes a deep(er) duplicate of the container.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.dup.html</link></decl><decl id="182" type="function"><name>reset</name><desc>&lt;div&gt;&lt;p&gt;Resets the buffer pointers but doesn't clear the contents.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.reset.html</link></decl><decl id="183" type="function"><name>clear</name><desc>&lt;div&gt;&lt;p&gt;Zeroes out the buffer's elements, getting rid of old contents.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.clear.html</link></decl></decl><decl id="184" type="struct"><name>RehashingAA</name><desc>&lt;div&gt;&lt;p&gt;A wrapper around a native associative array that you can controllably set to
    automatically rehash as entries are added.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.html</link><decl id="185" type="variable"><name>aa</name><desc>&lt;div&gt;&lt;p&gt;Internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.aa.html</link></decl><decl id="186" type="variable"><name>_numRehashes</name><desc>&lt;div&gt;&lt;p&gt;The number of times this instance has rehashed itself. Private value.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA._numRehashes.html</link></decl><decl id="187" type="variable"><name>_newKeysSinceLastRehash</name><desc>&lt;div&gt;&lt;p&gt;The number of new entries that has been added since the last rehash. Private value.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA._newKeysSinceLastRehash.html</link></decl><decl id="188" type="variable"><name>_lengthAtLastRehash</name><desc>&lt;div&gt;&lt;p&gt;The number of keys (and length of the array) when the last rehash took place.
        Private value.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA._lengthAtLastRehash.html</link></decl><decl id="189" type="variable"><name>minimumNeededForRehash</name><desc>&lt;div&gt;&lt;p&gt;The minimum number of additions needed before the first rehash takes place.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.minimumNeededForRehash.html</link></decl><decl id="190" type="variable"><name>rehashThresholdMultiplier</name><desc>&lt;div&gt;&lt;p&gt;The modifier by how much more entries must be added before another rehash
        takes place, with regards to the current &lt;a class=&quot;xref&quot; href=&quot;lu.container.RehashingAA.aa.html&quot;&gt;aa&lt;/a&gt; length.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.rehashThresholdMultiplier.html</link></decl><decl id="191" type="function"><name>opIndexAssign</name><desc>&lt;div&gt;&lt;p&gt;Assigns a value into the internal associative array. If it created a new
        entry, then call &lt;a class=&quot;xref&quot; href=&quot;lu.container.RehashingAA.maybeRehash.html&quot;&gt;maybeRehash&lt;/a&gt; to bump the internal counter and maybe rehash.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.opIndexAssign.html</link></decl><decl id="192" type="function"><name>opIndex</name><desc>&lt;div&gt;&lt;p&gt;Returns the value for the passed key in the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.opIndex.html</link></decl><decl id="193" type="function"><name>opIndexUnary</name><desc>&lt;div&gt;&lt;p&gt;Performs a unary operation on a value in the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.opIndexUnary.html</link></decl><decl id="194" type="function"><name>opAssign</name><desc>&lt;div&gt;&lt;p&gt;Inherit a native associative array into &lt;a class=&quot;xref&quot; href=&quot;lu.container.RehashingAA.aa.html&quot;&gt;aa&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.opAssign.html</link></decl><decl id="195" type="function"><name>opIndexOpAssign</name><desc>&lt;div&gt;&lt;p&gt;Performs an assignment operation on a value in the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.opIndexOpAssign.html</link></decl><decl id="196" type="function"><name>opCast</name><desc>&lt;div&gt;&lt;p&gt;Allows for casting this into the base associative array type.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.opCast.html</link></decl><decl id="197" type="function"><name>aaOf</name><desc>&lt;div&gt;&lt;p&gt;Returns the internal associative array, for when the wrapper is insufficient.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.aaOf.html</link></decl><decl id="198" type="function"><name>remove</name><desc>&lt;div&gt;&lt;p&gt;Removes a key from the &lt;a class=&quot;xref&quot; href=&quot;lu.container.RehashingAA.aa.html&quot;&gt;aa&lt;/a&gt; associative array by merely
        invoking &lt;tt class=&quot;inline-code&quot;&gt;.remove&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.remove.html</link></decl><decl id="199" type="function"><name>maybeRehash</name><desc>&lt;div&gt;&lt;p&gt;Bumps the internal counter of new keys since the last rehash, and depending
        on the resulting value of it, maybe rehashes.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.maybeRehash.html</link></decl><decl id="200" type="function"><name>clear</name><desc>&lt;div&gt;&lt;p&gt;Clears the internal associative array and all counters.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.clear.html</link></decl><decl id="201" type="function"><name>rehash</name><desc>&lt;div&gt;&lt;p&gt;Rehashes the internal associative array, bumping the rehash counter and
        zeroing the keys-added counter. Additionally invokes the &lt;a class=&quot;xref&quot; href=&quot;lu.container.RehashingAA.onRehashDg.html&quot;&gt;onRehashDg&lt;/a&gt; delegate.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.rehash.html</link></decl><decl id="202" type="function"><name>numRehashes</name><desc>&lt;div&gt;&lt;p&gt;The number of times this instance has rehashed itself. Accessor.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.numRehashes.html</link></decl><decl id="203" type="function"><name>newKeysSinceLastRehash</name><desc>&lt;div&gt;&lt;p&gt;The number of new entries that has been added since the last rehash. Accessor.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.newKeysSinceLastRehash.html</link></decl><decl id="204" type="function"><name>opBinaryRight</name><desc>&lt;div&gt;&lt;p&gt;Wraps &lt;tt class=&quot;inline-code&quot;&gt;key in aa&lt;/tt&gt; to the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.opBinaryRight.html</link></decl><decl id="205" type="function"><name>byValue</name><desc>&lt;div&gt;&lt;p&gt;Wraps the internal associative array's &lt;tt class=&quot;inline-code&quot;&gt;byValue&lt;/tt&gt; function.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.byValue.html</link></decl><decl id="206" type="function"><name>byKey</name><desc>&lt;div&gt;&lt;p&gt;Wraps the internal associative array's &lt;tt class=&quot;inline-code&quot;&gt;byKey&lt;/tt&gt; function.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.byKey.html</link></decl><decl id="207" type="function"><name>values</name><desc>&lt;div&gt;&lt;p&gt;Wraps the internal associative array's &lt;tt class=&quot;inline-code&quot;&gt;values&lt;/tt&gt; function.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.values.html</link></decl><decl id="208" type="function"><name>keys</name><desc>&lt;div&gt;&lt;p&gt;Wraps the internal associative array's &lt;tt class=&quot;inline-code&quot;&gt;keys&lt;/tt&gt; function.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.keys.html</link></decl><decl id="209" type="function"><name>byKeyValue</name><desc>&lt;div&gt;&lt;p&gt;Wraps the internal associative array's &lt;tt class=&quot;inline-code&quot;&gt;byKeyValue&lt;/tt&gt; function.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.byKeyValue.html</link></decl><decl id="210" type="function"><name>length</name><desc>&lt;div&gt;&lt;p&gt;Returns the length of the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.length.html</link></decl><decl id="211" type="function"><name>dup</name><desc>&lt;div&gt;&lt;p&gt;Duplicates this. Explicitly copies the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.dup.html</link></decl><decl id="212" type="function"><name>require</name><desc>&lt;div&gt;&lt;p&gt;Returns the value for the key &lt;tt class=&quot;inline-code&quot;&gt;key&lt;/tt&gt;, inserting &lt;tt class=&quot;inline-code&quot;&gt;value&lt;/tt&gt; lazily if it is not present.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.require.html</link></decl><decl id="213" type="function"><name>get</name><desc>&lt;div&gt;&lt;p&gt;Retrieves the value for the key &lt;tt class=&quot;inline-code&quot;&gt;key&lt;/tt&gt;, or returns the default &lt;tt class=&quot;inline-code&quot;&gt;value&lt;/tt&gt;
        if there was none.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.get.html</link></decl><decl id="214" type="function"><name>uniqueKey</name><desc>&lt;div&gt;&lt;p&gt;Reserves a unique key in the associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.uniqueKey.html</link></decl><decl id="215" type="function"><name>update</name><desc>&lt;div&gt;&lt;p&gt;Updates the value for the key &lt;tt class=&quot;inline-code&quot;&gt;key&lt;/tt&gt; in the internal associative array,
        invoking the first of the passed delegate to insert a new value if it
        doesn't exist, or the second selegate to modify it in place if it does.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.update.html</link></decl><decl id="216" type="function"><name>opEquals</name><desc>&lt;div&gt;&lt;p&gt;Implements &lt;tt class=&quot;inline-code&quot;&gt;opEquals&lt;/tt&gt; for this type, comparing the internal associative
        array with that of another &lt;tt class=&quot;inline-code&quot;&gt;RehashingAA&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.opEquals.1.html</link></decl><decl id="217" type="function"><name>opEquals</name><desc>&lt;div&gt;&lt;p&gt;Implements &lt;tt class=&quot;inline-code&quot;&gt;opEquals&lt;/tt&gt; for this type, comparing the internal associative
        array with a different one.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.opEquals.2.html</link></decl><decl id="218" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Constructor.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.this.html</link></decl><decl id="219" type="variable"><name>onRehashDg</name><desc>&lt;div&gt;&lt;p&gt;Delegate called when rehashing takes place.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.onRehashDg.html</link></decl></decl><decl id="220" type="function"><name>rehashingAA</name><desc>&lt;div&gt;&lt;p&gt;Convenience helper to instantiate a &lt;a class=&quot;xref&quot; href=&quot;lu.container.RehashingAA.html&quot;&gt;RehashingAA&lt;/a&gt; instance with an
    existing associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.rehashingAA.html</link></decl><decl id="221" type="struct"><name>MutexedAA</name><desc>&lt;div&gt;&lt;p&gt;An associative array and a &lt;a class=&quot;xref&quot; href=&quot;core.sync.mutex.Mutex.html&quot;&gt;Mutex&lt;/a&gt;. Wraps associative
    array operations in mutex locks.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.html</link><decl id="222" type="variable"><name>mutex</name><desc>&lt;div&gt;&lt;p&gt;&lt;a class=&quot;xref&quot; href=&quot;core.sync.mutex.Mutex.html&quot;&gt;Mutex&lt;/a&gt; to lock the associative array with.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.mutex.html</link></decl><decl id="223" type="variable"><name>aa</name><desc>&lt;div&gt;&lt;p&gt;The internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.aa.html</link></decl><decl id="224" type="function"><name>setup</name><desc>&lt;div&gt;&lt;p&gt;Sets up this instance. Does nothing if it has already been set up.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.setup.html</link></decl><decl id="225" type="function"><name>aaOf</name><desc>&lt;div&gt;&lt;p&gt;Returns the internal associative array, for when the wrapper is insufficient.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.aaOf.html</link></decl><decl id="226" type="function"><name>isReady</name><desc>&lt;div&gt;&lt;p&gt;Returns whether or not this instance has been set up.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.isReady.html</link></decl><decl id="227" type="function"><name>opIndexAssign</name><desc>&lt;div&gt;&lt;p&gt;&lt;tt class=&quot;inline-code&quot;&gt;aa[key] = value&lt;/tt&gt; array assign operation, wrapped in a mutex lock.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.opIndexAssign.html</link></decl><decl id="228" type="function"><name>opIndex</name><desc>&lt;div&gt;&lt;p&gt;&lt;tt class=&quot;inline-code&quot;&gt;aa[key]&lt;/tt&gt; array retrieve operation, wrapped in a mutex lock.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.opIndex.html</link></decl><decl id="229" type="function"><name>has</name><desc>&lt;div&gt;&lt;p&gt;Returns whether or not the passed key is in the associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.has.html</link></decl><decl id="230" type="function"><name>remove</name><desc>&lt;div&gt;&lt;p&gt;&lt;tt class=&quot;inline-code&quot;&gt;aa.remove(key)&lt;/tt&gt; array operation, wrapped in a mutex lock.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.remove.html</link></decl><decl id="231" type="function"><name>uniqueKey</name><desc>&lt;div&gt;&lt;p&gt;Reserves a unique key in the associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.uniqueKey.html</link></decl><decl id="232" type="function"><name>opEquals</name><desc>&lt;div&gt;&lt;p&gt;Implements &lt;tt class=&quot;inline-code&quot;&gt;opEquals&lt;/tt&gt; for this type, comparing the internal associative
        array with that of another &lt;tt class=&quot;inline-code&quot;&gt;MutexedAA&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.opEquals.1.html</link></decl><decl id="233" type="function"><name>opEquals</name><desc>&lt;div&gt;&lt;p&gt;Implements &lt;tt class=&quot;inline-code&quot;&gt;opEquals&lt;/tt&gt; for this type, comparing the internal associative
        array with a different one.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.opEquals.2.html</link></decl><decl id="234" type="function"><name>rehash</name><desc>&lt;div&gt;&lt;p&gt;Rehashes the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.rehash.html</link></decl><decl id="235" type="function"><name>clear</name><desc>&lt;div&gt;&lt;p&gt;Clears the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.clear.html</link></decl><decl id="236" type="function"><name>length</name><desc>&lt;div&gt;&lt;p&gt;Returns the length of the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.length.html</link></decl><decl id="237" type="function"><name>require</name><desc>&lt;div&gt;&lt;p&gt;Returns the value for the key &lt;tt class=&quot;inline-code&quot;&gt;key&lt;/tt&gt;, inserting &lt;tt class=&quot;inline-code&quot;&gt;value&lt;/tt&gt; lazily if it is not present.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.require.html</link></decl><decl id="238" type="function"><name>keys</name><desc>&lt;div&gt;&lt;p&gt;Returns a new dynamic array of all the keys in the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.keys.html</link></decl><decl id="239" type="function"><name>values</name><desc>&lt;div&gt;&lt;p&gt;Returns a new dynamic array of all the values in the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.values.html</link></decl><decl id="240" type="function"><name>get</name><desc>&lt;div&gt;&lt;p&gt;Retrieves the value for the key &lt;tt class=&quot;inline-code&quot;&gt;key&lt;/tt&gt;, or returns the default &lt;tt class=&quot;inline-code&quot;&gt;value&lt;/tt&gt;
        if there was none.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.get.html</link></decl><decl id="241" type="function"><name>update</name><desc>&lt;div&gt;&lt;p&gt;Updates the value for the key &lt;tt class=&quot;inline-code&quot;&gt;key&lt;/tt&gt; in the internal associative array,
        invoking the first of the passed delegate to insert a new value if it
        doesn't exist, or the second selegate to modify it in place if it does.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.update.html</link></decl><decl id="242" type="function"><name>opIndexUnary</name><desc>&lt;div&gt;&lt;p&gt;Implements unary operations by mixin strings.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.opIndexUnary.html</link></decl><decl id="243" type="function"><name>opIndexOpAssign</name><desc>&lt;div&gt;&lt;p&gt;Implements index assign operations by mixin strings.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.opIndexOpAssign.html</link></decl></decl><decl id="244" type="function"><name>mutexedAA</name><desc>&lt;div&gt;&lt;p&gt;Convenience function to create and setup a &lt;a class=&quot;xref&quot; href=&quot;lu.container.MutexedAA.html&quot;&gt;MutexedAA&lt;/a&gt; instance in one go.
    &lt;a class=&quot;xref&quot; href=&quot;lu.container.MutexedAA.setup.html&quot;&gt;MutexedAA.setup&lt;/a&gt; need as such not be called.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.mutexedAA.1.html</link></decl><decl id="245" type="function"><name>mutexedAA</name><desc>&lt;div&gt;&lt;p&gt;Convenience function to create and setup a &lt;a class=&quot;xref&quot; href=&quot;lu.container.MutexedAA.html&quot;&gt;MutexedAA&lt;/a&gt; instance.
    Overload that inherits an original associative array, or optionally duplicates it.
    Infers the types to instantiate the &lt;a class=&quot;xref&quot; href=&quot;lu.container.MutexedAA.html&quot;&gt;MutexedAA&lt;/a&gt; with from the AA passed.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.mutexedAA.2.html</link></decl></decl><decl id="246" type="module"><name>lu.json</name><desc>&lt;div&gt;&lt;p&gt;Simple wrappers around Phobos &lt;a class=&quot;xref&quot; href=&quot;std.json.html&quot;&gt;std.json&lt;/a&gt;. This is *not* a replacement for it.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.html</link><decl id="247" type="struct"><name>JSONStorage</name><desc>&lt;div&gt;&lt;p&gt;A wrapped &lt;a class=&quot;xref&quot; href=&quot;std.json.JSONValue.html&quot;&gt;JSONValue&lt;/a&gt; with helper functions.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.JSONStorage.html</link><decl id="248" type="variable"><name>storage</name><desc>&lt;div&gt;&lt;p&gt;The underlying &lt;a class=&quot;xref&quot; href=&quot;std.json.JSONValue.html&quot;&gt;JSONValue&lt;/a&gt; storage of this &lt;a class=&quot;xref&quot; href=&quot;lu.json.JSONStorage.html&quot;&gt;JSONStorage&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.JSONStorage.storage.html</link></decl><decl id="249" type="enum"><name>KeyOrderStrategy</name><desc>&lt;div&gt;&lt;p&gt;Strategy with which to sort object-type JSON keys when we format/serialise
        the stored &lt;a class=&quot;xref&quot; href=&quot;lu.json.JSONStorage.storage.html&quot;&gt;storage&lt;/a&gt; to string.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.JSONStorage.KeyOrderStrategy.html</link></decl><decl id="250" type="function"><name>reset</name><desc>&lt;div&gt;&lt;p&gt;Initialises and clears the &lt;a class=&quot;xref&quot; href=&quot;std.json.JSONValue.html&quot;&gt;JSONValue&lt;/a&gt;, preparing
        it for object storage.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.JSONStorage.reset.html</link></decl><decl id="251" type="function"><name>load</name><desc>&lt;div&gt;&lt;p&gt;Loads JSON from disk.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.JSONStorage.load.html</link></decl><decl id="252" type="function"><name>save</name><desc>&lt;div&gt;&lt;p&gt;Saves the JSON storage to disk. Formatting is done as specified by the
        passed &lt;a class=&quot;xref&quot; href=&quot;lu.json.JSONStorage.KeyOrderStrategy.html&quot;&gt;KeyOrderStrategy&lt;/a&gt; argument.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.JSONStorage.save.html</link></decl><decl id="253" type="function"><name>serialiseInto</name><desc>&lt;div&gt;&lt;p&gt;Formats an object-type JSON storage into an output range sink.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.JSONStorage.serialiseInto.1.html</link></decl><decl id="254" type="function"><name>serialiseInto</name><desc>&lt;div&gt;&lt;p&gt;Formats an object-type JSON storage into an output range sink.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.JSONStorage.serialiseInto.2.html</link></decl></decl><decl id="255" type="function"><name>populateFromJSON</name><desc>&lt;div&gt;&lt;p&gt;Recursively populates a passed associative or dynamic array with the
    contents of a &lt;a class=&quot;xref&quot; href=&quot;std.json.JSONValue.html&quot;&gt;JSONValue&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.populateFromJSON.html</link></decl><decl id="256" type="function"><name>safelyGet</name><desc>&lt;div&gt;&lt;p&gt;Fetches a value from a &lt;a class=&quot;xref&quot; href=&quot;std.json.JSONValue.html&quot;&gt;JSONValue&lt;/a&gt;, or returns a fallback
    value if the key doesn't exist in the object.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.safelyGet.html</link></decl><decl id="257" type="alias"><name>getOrFallback</name><desc>&lt;div&gt;&lt;p&gt;Compatibility alias to &lt;a class=&quot;xref&quot; href=&quot;lu.json.safelyGet.html&quot;&gt;safelyGet&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.getOrFallback.html</link></decl></decl><decl id="258" type="module"><name>lu.meld</name><desc>&lt;div&gt;&lt;p&gt;This module contains the &lt;a class=&quot;xref&quot; href=&quot;lu.meld.meldInto.3.html&quot;&gt;meldInto&lt;/a&gt; functions; functions that take two
    structs or classes of the same type and combine them, creating a resulting
    object with the union of the members of both parents. Array and associative
    array variants exist too.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.meld.html</link><decl id="259" type="enum"><name>MeldingStrategy</name><desc>&lt;div&gt;&lt;p&gt;To what extent a source should overwrite a target when melding.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.meld.MeldingStrategy.html</link></decl><decl id="260" type="function"><name>meldInto</name><desc>&lt;div&gt;&lt;p&gt;Takes two structs or classes of the same type and melds them together,
    making the members of the resulting aggregate a union of the two.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.meld.meldInto.1.html</link></decl><decl id="261" type="function"><name>meldInto</name><desc>&lt;div&gt;&lt;p&gt;Takes two arrays and melds them together, making a union of the two.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.meld.meldInto.2.html</link></decl><decl id="262" type="function"><name>meldInto</name><desc>&lt;div&gt;&lt;p&gt;Takes two associative arrays and melds them together, making a union of the two.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.meld.meldInto.3.html</link></decl></decl><decl id="263" type="module"><name>lu.conv</name><desc>&lt;div&gt;&lt;p&gt;This module contains functions that in one way or another converts its
    arguments into something else.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.conv.html</link><decl id="264" type="template"><name>Enum</name><desc>&lt;div&gt;&lt;p&gt;Template housing optimised functions to get the string name of an enum
    member, or the enum member of a name string.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.conv.Enum.html</link><decl id="265" type="function"><name>fromString</name><desc>&lt;div&gt;&lt;p&gt;Takes the member of an enum by string and returns the member of that name.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.conv.Enum.fromString.html</link></decl><decl id="266" type="function"><name>toString</name><desc>&lt;div&gt;&lt;p&gt;The inverse of &lt;a class=&quot;xref&quot; href=&quot;lu.conv.Enum.fromString.html&quot;&gt;fromString&lt;/a&gt;, this function takes an enum member value
        and returns its string identifier.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.conv.Enum.toString.html</link></decl></decl><decl id="267" type="function"><name>toString</name><desc>&lt;div&gt;&lt;p&gt;Convenience wrapper around &lt;a class=&quot;xref&quot; href=&quot;lu.conv.Enum.toString.html&quot;&gt;Enum.toString&lt;/a&gt; that infers the type
    to instantiate it with from the passed enum member.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.conv.toString.html</link></decl><decl id="268" type="alias"><name>enumToString</name><desc>&lt;div&gt;&lt;p&gt;Deprecated alias of &lt;a class=&quot;xref&quot; href=&quot;lu.conv.toString.html&quot;&gt;toString&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.conv.enumToString.html</link></decl><decl id="269" type="function"><name>numFromHex</name><desc>&lt;div&gt;&lt;p&gt;Returns the decimal value of a hex number in string form.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.conv.numFromHex.html</link></decl><decl id="270" type="function"><name>rgbFromHex</name><desc>&lt;div&gt;&lt;p&gt;Convenience wrapper that takes a hex string and populates a Voldemort
    struct with its integer RR, GG and BB components.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.conv.rgbFromHex.html</link></decl><decl id="271" type="function"><name>toAlphaInto</name><desc>&lt;div&gt;&lt;p&gt;Translates an integer into an alphanumeric string.
    Overload that takes an output range sink.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.conv.toAlphaInto.html</link></decl><decl id="272" type="function"><name>toAlpha</name><desc>&lt;div&gt;&lt;p&gt;Translates an integer into an alphanumeric string.
    Overload that returns the string.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.conv.toAlpha.html</link></decl></decl><decl id="273" type="module"><name>lu.uda</name><desc>&lt;div&gt;&lt;p&gt;Common user-defined attributes (UDAs).&lt;/p&gt;&lt;/div&gt;</desc><link>lu.uda.html</link><decl id="274" type="enum"><name>Unserialisable</name><desc>&lt;div&gt;&lt;p&gt;UDA conveying that the annotated member cannot (or should not) be serialised.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.uda.Unserialisable.html</link></decl><decl id="275" type="struct"><name>Separator</name><desc>&lt;div&gt;&lt;p&gt;UDA conveying that the annotated array should have this token as separator
    when formatted to a string.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.uda.Separator.html</link><decl id="276" type="variable"><name>token</name><desc>&lt;div&gt;&lt;p&gt;Separator, can be more than one character.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.uda.Separator.token.html</link></decl></decl><decl id="277" type="enum"><name>Hidden</name><desc>&lt;div&gt;&lt;p&gt;UDA conveying that the annotated member contains sensitive information and
    should not be printed in clear text; e.g. passwords.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.uda.Hidden.html</link></decl><decl id="278" type="enum"><name>CannotContainComments</name><desc>&lt;div&gt;&lt;p&gt;UDA conveying that the annotated member may contain characters that would
    otherwise indicate a comment, and that this should be ignored.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.uda.CannotContainComments.html</link></decl><decl id="279" type="enum"><name>Quoted</name><desc>&lt;div&gt;&lt;p&gt;UDA conveying that the annotated member's value must be quoted when serialised.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.uda.Quoted.html</link></decl><decl id="280" type="enum"><name>Unmeldable</name><desc>&lt;div&gt;&lt;p&gt;UDA conveying that the annotated member's value cannot or should not be melded.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.uda.Unmeldable.html</link></decl></decl><decl id="281" type="module"><name>lu.typecons</name><desc>&lt;div&gt;&lt;p&gt;Type constructors.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.typecons.html</link><decl id="282" type="mixin template"><name>OpDispatcher</name><desc>&lt;div&gt;&lt;p&gt;Mixin template generating an &lt;tt class=&quot;inline-code&quot;&gt;opDispatch&lt;/tt&gt; redirecting calls to members whose
    names match the passed variable string but with a given token string in
    the front or at the end of the name.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.typecons.OpDispatcher.html</link><decl id="283" type="function"><name>opDispatch</name><desc>&lt;div&gt;&lt;p&gt;Mutator.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.typecons.OpDispatcher.opDispatch.1.html</link></decl><decl id="284" type="function"><name>opDispatch</name><desc>&lt;div&gt;&lt;p&gt;Accessor.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.typecons.OpDispatcher.opDispatch.2.html</link></decl></decl><decl id="285" type="mixin template"><name>UnderscoreOpDispatcher</name><desc>&lt;div&gt;&lt;p&gt;Mixin template generating an &lt;tt class=&quot;inline-code&quot;&gt;opDispatch&lt;/tt&gt; redirecting calls to members whose
    names match the passed variable string but with an underscore prepended to
    the name.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.typecons.UnderscoreOpDispatcher.html</link></decl></decl><decl id="286" type="module"><name>lu.serialisation</name><desc>&lt;div&gt;&lt;p&gt;Various functions related to serialising and deserialising structs into/from
    configuration file-y files.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.html</link><decl id="287" type="function"><name>serialise</name><desc>&lt;div&gt;&lt;p&gt;Convenience function to call &lt;a class=&quot;xref&quot; href=&quot;lu.serialisation.serialise.2.html&quot;&gt;serialise&lt;/a&gt; on several objects.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.serialise.1.html</link></decl><decl id="288" type="function"><name>serialise</name><desc>&lt;div&gt;&lt;p&gt;Serialises the fields of an object into a configuration file-y format.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.serialise.2.html</link></decl><decl id="289" type="struct"><name>SerialisationUDAs</name><desc>&lt;div&gt;&lt;p&gt;Summary of UDAs that an array to be serialised is annotated with.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.SerialisationUDAs.html</link><decl id="290" type="variable"><name>unserialisable</name><desc>&lt;div&gt;&lt;p&gt;The value of the &lt;a class=&quot;xref&quot; href=&quot;lu.uda.Separator.html&quot;&gt;Separator&lt;/a&gt; UDA the array was
        annotated with.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.SerialisationUDAs.unserialisable.html</link></decl><decl id="291" type="variable"><name>separator</name><desc>&lt;div&gt;&lt;p&gt;The value of the &lt;a class=&quot;xref&quot; href=&quot;lu.uda.Separator.html&quot;&gt;Separator&lt;/a&gt; UDA the array was
        annotated with.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.SerialisationUDAs.separator.html</link></decl><decl id="292" type="variable"><name>escapedSeparator</name><desc>&lt;div&gt;&lt;p&gt;The escaped form of &lt;a class=&quot;xref&quot; href=&quot;lu.serialisation.SerialisationUDAs.separator.html&quot;&gt;separator&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.SerialisationUDAs.escapedSeparator.html</link></decl><decl id="293" type="variable"><name>arrayPattern</name><desc>&lt;div&gt;&lt;p&gt;The &lt;a class=&quot;xref&quot; href=&quot;std.format.format.html&quot;&gt;format&lt;/a&gt; pattern used to format the array this struct
        refers to. This is separator-specific.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.SerialisationUDAs.arrayPattern.html</link></decl></decl><decl id="294" type="function"><name>serialiseArrayImpl</name><desc>&lt;div&gt;&lt;p&gt;Serialises a non-string array into a single row. To be used when serialising
    an aggregate with &lt;a class=&quot;xref&quot; href=&quot;lu.serialisation.serialise.2.html&quot;&gt;serialise&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.serialiseArrayImpl.html</link></decl><decl id="295" type="function"><name>deserialise</name><desc>&lt;div&gt;&lt;p&gt;Takes an input range containing serialised entry-value text and applies the
    contents therein to one or more passed struct/class objects.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.deserialise.html</link></decl><decl id="296" type="function"><name>justifiedEntryValueText</name><desc>&lt;div&gt;&lt;p&gt;Takes an unformatted string of serialised entry-value text and justifies it
    into two neat columns.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.justifiedEntryValueText.html</link></decl><decl id="297" type="class"><name>DeserialisationException</name><desc>&lt;div&gt;&lt;p&gt;Exception, to be thrown when the specified serialised text could not be
    parsed, for whatever reason.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.DeserialisationException.html</link><decl id="298" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.serialisation.DeserialisationException.html&quot;&gt;DeserialisationException&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.DeserialisationException.this.html</link></decl></decl><decl id="299" type="function"><name>splitEntryValue</name><desc>&lt;div&gt;&lt;p&gt;Splits a line into an entry and a value component.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.splitEntryValue.html</link></decl></decl></decl><decl id="300" type="module"><name>lu.array</name><desc>&lt;div&gt;&lt;p&gt;Simple array utilities.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.html</link><decl id="301" type="function"><name>uniqueKey</name><desc>&lt;div&gt;&lt;p&gt;Returns a unique key for the passed associative array. Reserves the key by
    assigning it a value.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.uniqueKey.html</link></decl><decl id="302" type="function"><name>zero</name><desc>&lt;div&gt;&lt;p&gt;Zeroes out the contents of an &lt;a class=&quot;xref&quot; href=&quot;std.array.Appender.html&quot;&gt;Appender&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.zero.html</link></decl><decl id="303" type="function"><name>truthTable</name><desc>&lt;div&gt;&lt;p&gt;Generates a truth table from a list of runtime numbers.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.truthTable.1.html</link></decl><decl id="304" type="function"><name>truthTable</name><desc>&lt;div&gt;&lt;p&gt;Generates a truth table from a list of runtime enum values.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.truthTable.2.html</link></decl><decl id="305" type="function"><name>truthTable</name><desc>&lt;div&gt;&lt;p&gt;Generates a static truth table from a list of compile-time numbers.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.truthTable.3.html</link></decl><decl id="306" type="function"><name>truthTable</name><desc>&lt;div&gt;&lt;p&gt;Generates a static truth table from a list of compile-time enum values.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.truthTable.4.html</link></decl><decl id="307" type="class"><name>ArrayException</name><desc>&lt;div&gt;&lt;p&gt;Exception, to be thrown when there was an array-related error.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.ArrayException.html</link><decl id="308" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.array.ArrayException.html&quot;&gt;ArrayException&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.ArrayException.this.html</link></decl></decl><decl id="309" type="function"><name>pruneAA</name><desc>&lt;div&gt;&lt;p&gt;Iterates an associative array and deletes invalid entries, either if the value
    is in a default &lt;tt class=&quot;inline-code&quot;&gt;.init&lt;/tt&gt; state or as per the optionally passed predicate.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.pruneAA.html</link></decl><decl id="310" type="function"><name>countUntilLastOccurrenceOf</name><desc>&lt;div&gt;&lt;p&gt;Finds the index of the last occurrence of a needle in a haystack.
    The needle may be a single element (character) or an array of the same type
    as the haystack.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.countUntilLastOccurrenceOf.html</link></decl><decl id="311" type="function"><name>countUntilLastMatchOf</name><desc>&lt;div&gt;&lt;p&gt;Finds the index of the last match of a predicate in a haystack. The predicate
    is evaluated against each element.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.array.countUntilLastMatchOf.html</link></decl></decl><decl id="312" type="module"><name>lu.common</name><desc>&lt;div&gt;&lt;p&gt;Compatibility module publicly importing symbols from &lt;a class=&quot;xref&quot; href=&quot;lu.misc.html&quot;&gt;lu.misc&lt;/a&gt;.
    Import symbols directly from &lt;a class=&quot;xref&quot; href=&quot;lu.misc.html&quot;&gt;lu.misc&lt;/a&gt; instead.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.common.html</link></decl><decl id="313" type="module"><name>lu.semver</name><desc>&lt;div&gt;&lt;p&gt;SemVer information about the current release.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.semver.html</link><decl id="314" type="enum"><name>LuSemVer</name><desc>&lt;div&gt;&lt;p&gt;SemVer versioning of this build.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.semver.LuSemVer.html</link></decl><decl id="315" type="manifest constant"><name>LuSemVerPrerelease</name><desc>&lt;div&gt;&lt;p&gt;Pre-release SemVer subversion of this build.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.semver.LuSemVerPrerelease.html</link></decl></decl><decl id="316" type="module"><name>lu.numeric</name><desc>&lt;div&gt;&lt;p&gt;Functions and templates that do calculations or other numeric manipulation,
    in some way or another.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.numeric.html</link><decl id="317" type="function"><name>getMultipleOf</name><desc>&lt;div&gt;&lt;p&gt;Given a number, calculate the largest multiple of &lt;tt class=&quot;inline-code&quot;&gt;n&lt;/tt&gt; needed to reach that number.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.numeric.getMultipleOf.html</link></decl></decl><decl id="318" type="module"><name>lu.objmanip</name><desc>&lt;div&gt;&lt;p&gt;This module contains functions that in some way or another manipulates
    struct and class instances, as well as (associative) arrays.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.objmanip.html</link><decl id="319" type="function"><name>setMemberByName</name><desc>&lt;div&gt;&lt;p&gt;Given a struct/class object, sets one of its members by its string name to a
    specified value. Overload that takes the value as a string and tries to
    convert it into the target type.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.objmanip.setMemberByName.1.html</link></decl><decl id="320" type="function"><name>setMemberByName</name><desc>&lt;div&gt;&lt;p&gt;Given a struct/class object, sets one of its members by its string name to a
    specified value. Overload that takes a value of the same type as the target
    member, rather than a string to convert. Integer promotion applies.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.objmanip.setMemberByName.2.html</link></decl><decl id="321" type="class"><name>SetMemberException</name><desc>&lt;div&gt;&lt;p&gt;Exception, to be thrown when &lt;a class=&quot;xref&quot; href=&quot;lu.objmanip.setMemberByName.2.html&quot;&gt;setMemberByName&lt;/a&gt; fails for some given reason.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.objmanip.SetMemberException.html</link><decl id="322" type="variable"><name>typeName</name><desc>&lt;div&gt;&lt;p&gt;Name of type that was attempted to set the member of.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.objmanip.SetMemberException.typeName.html</link></decl><decl id="323" type="variable"><name>memberToSet</name><desc>&lt;div&gt;&lt;p&gt;Name of the member that was attempted to set.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.objmanip.SetMemberException.memberToSet.html</link></decl><decl id="324" type="variable"><name>valueToSet</name><desc>&lt;div&gt;&lt;p&gt;String representation of the value that was attempted to assign.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.objmanip.SetMemberException.valueToSet.html</link></decl><decl id="325" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.objmanip.SetMemberException.html&quot;&gt;SetMemberException&lt;/a&gt;, without attaching anything.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.objmanip.SetMemberException.this.1.html</link></decl><decl id="326" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.objmanip.SetMemberException.html&quot;&gt;SetMemberException&lt;/a&gt;, attaching extra set-member information.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.objmanip.SetMemberException.this.2.html</link></decl></decl><decl id="327" type="function"><name>replaceMembers</name><desc>&lt;div&gt;&lt;p&gt;Inspects a passed struct or class for members whose values match that of the
    passed &lt;tt class=&quot;inline-code&quot;&gt;token&lt;/tt&gt;. Matches members are set to a replacement value, which is
    an optional parameter that defaults to the &lt;tt class=&quot;inline-code&quot;&gt;.init&lt;/tt&gt; value of the token's type.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.objmanip.replaceMembers.html</link></decl></decl><decl id="328" type="module"><name>lu.misc</name><desc>&lt;div&gt;&lt;p&gt;Things that don't have a better home yet.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.html</link><decl id="329" type="enum"><name>Next</name><desc>&lt;div&gt;&lt;p&gt;Enum of flags carrying the meaning of &amp;quot;what to do next&amp;quot;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.Next.html</link></decl><decl id="330" type="class"><name>ReturnValueException</name><desc>&lt;div&gt;&lt;p&gt;Exception, to be thrown when an executed command returns an error value.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.ReturnValueException.html</link><decl id="331" type="variable"><name>command</name><desc>&lt;div&gt;&lt;p&gt;The command run.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.ReturnValueException.command.html</link></decl><decl id="332" type="variable"><name>retval</name><desc>&lt;div&gt;&lt;p&gt;The value returned.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.ReturnValueException.retval.html</link></decl><decl id="333" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.misc.ReturnValueException.html&quot;&gt;ReturnValueException&lt;/a&gt;, without attaching anything.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.ReturnValueException.this.1.html</link></decl><decl id="334" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.misc.ReturnValueException.html&quot;&gt;ReturnValueException&lt;/a&gt;, attaching a command.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.ReturnValueException.this.2.html</link></decl><decl id="335" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.misc.ReturnValueException.html&quot;&gt;ReturnValueException&lt;/a&gt;, attaching a command and a returned value.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.ReturnValueException.this.3.html</link></decl></decl><decl id="336" type="class"><name>FileExistsException</name><desc>&lt;div&gt;&lt;p&gt;Exception, to be thrown when attempting to create a file or directory and
    finding that one already exists with the same name.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.FileExistsException.html</link><decl id="337" type="variable"><name>filename</name><desc>&lt;div&gt;&lt;p&gt;The name of the file.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.FileExistsException.filename.html</link></decl><decl id="338" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.misc.FileExistsException.html&quot;&gt;FileExistsException&lt;/a&gt;, without attaching a filename.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.FileExistsException.this.1.html</link></decl><decl id="339" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.misc.FileExistsException.html&quot;&gt;FileExistsException&lt;/a&gt;, attaching a filename.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.FileExistsException.this.2.html</link></decl></decl><decl id="340" type="class"><name>FileTypeMismatchException</name><desc>&lt;div&gt;&lt;p&gt;Exception, to be thrown when attempting to access a file or directory and
    finding that something with the that name exists, but is of an unexpected type.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.FileTypeMismatchException.html</link><decl id="341" type="variable"><name>filename</name><desc>&lt;div&gt;&lt;p&gt;The filename of the file in question.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.FileTypeMismatchException.filename.html</link></decl><decl id="342" type="variable"><name>attrs</name><desc>&lt;div&gt;&lt;p&gt;File attributes.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.FileTypeMismatchException.attrs.html</link></decl><decl id="343" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.misc.FileTypeMismatchException.html&quot;&gt;FileTypeMismatchException&lt;/a&gt;, without embedding a filename.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.FileTypeMismatchException.this.1.html</link></decl><decl id="344" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.misc.FileTypeMismatchException.html&quot;&gt;FileTypeMismatchException&lt;/a&gt;, embedding a filename.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.FileTypeMismatchException.this.2.html</link></decl></decl><decl id="345" type="function"><name>sharedDomains</name><desc>&lt;div&gt;&lt;p&gt;Calculates how many dot-separated domains two strings share.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.misc.sharedDomains.html</link></decl></decl><decl id="346" type="module"><name>lu.assert_</name><desc>&lt;div&gt;&lt;p&gt;Assertion helpers.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.assert_.html</link><decl id="347" type="function"><name>assertMultilineEquals</name><desc>&lt;div&gt;&lt;p&gt;Asserts that two multiple-line strings are equal, with a more detailed error
    message than the yes/no of the built-in &lt;tt class=&quot;inline-code&quot;&gt;assert()&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.assert_.assertMultilineEquals.html</link></decl></decl><decl id="348" type="module"><name>lu.string</name><desc>&lt;div&gt;&lt;p&gt;String manipulation functions.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.html</link><decl id="349" type="function"><name>advancePast</name><desc>&lt;div&gt;&lt;p&gt;Given a reference to some string, finds the supplied needle token in it, returns the
    string up to that point, and advances the passed ref string to after the token.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.advancePast.html</link></decl><decl id="350" type="class"><name>AdvanceException</name><desc>&lt;div&gt;&lt;p&gt;Exception, to be thrown when a call to &lt;a class=&quot;xref&quot; href=&quot;lu.string.advancePast.html&quot;&gt;advancePast&lt;/a&gt; went wrong.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceException.html</link><decl id="351" type="function"><name>haystack</name><desc>&lt;div&gt;&lt;p&gt;Returns a string of the original haystack the call to &lt;a class=&quot;xref&quot; href=&quot;lu.string.advancePast.html&quot;&gt;advancePast&lt;/a&gt; was operating on.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceException.haystack.html</link></decl><decl id="352" type="function"><name>needle</name><desc>&lt;div&gt;&lt;p&gt;Returns a string of the original needle the call to &lt;a class=&quot;xref&quot; href=&quot;lu.string.advancePast.html&quot;&gt;advancePast&lt;/a&gt; was operating on.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceException.needle.html</link></decl><decl id="353" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.string.AdvanceExceptionImpl.html&quot;&gt;AdvanceExceptionImpl&lt;/a&gt;, without attaching anything.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceException.this.html</link></decl></decl><decl id="354" type="class"><name>AdvanceExceptionImpl</name><desc>&lt;div&gt;&lt;p&gt;Exception, to be thrown when a call to &lt;a class=&quot;xref&quot; href=&quot;lu.string.advancePast.html&quot;&gt;advancePast&lt;/a&gt; went wrong.
    This is the templated implementation, so that we can support more than one
    kind of needle and haystack combination.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceExceptionImpl.html</link><decl id="355" type="variable"><name>_haystack</name><desc>&lt;div&gt;&lt;p&gt;Raw haystack that &lt;tt class=&quot;inline-code&quot;&gt;haystack&lt;/tt&gt; converts to string and returns.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceExceptionImpl._haystack.html</link></decl><decl id="356" type="variable"><name>_needle</name><desc>&lt;div&gt;&lt;p&gt;Raw needle that &lt;tt class=&quot;inline-code&quot;&gt;needle&lt;/tt&gt; converts to string and returns.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceExceptionImpl._needle.html</link></decl><decl id="357" type="function"><name>haystack</name><desc>&lt;div&gt;&lt;p&gt;Returns a string of the original needle the call to &lt;tt class=&quot;inline-code&quot;&gt;advancePast&lt;/tt&gt; was operating on.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceExceptionImpl.haystack.html</link></decl><decl id="358" type="function"><name>needle</name><desc>&lt;div&gt;&lt;p&gt;Returns a string of the original needle the call to &lt;tt class=&quot;inline-code&quot;&gt;advancePast&lt;/tt&gt; was operating on.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceExceptionImpl.needle.html</link></decl><decl id="359" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;tt class=&quot;inline-code&quot;&gt;AdvanceExceptionImpl&lt;/tt&gt;, without attaching anything.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceExceptionImpl.this.1.html</link></decl><decl id="360" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;tt class=&quot;inline-code&quot;&gt;AdvanceExceptionImpl&lt;/tt&gt;, attaching a command.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.AdvanceExceptionImpl.this.2.html</link></decl></decl><decl id="361" type="function"><name>plurality</name><desc>&lt;div&gt;&lt;p&gt;Returns the singular or plural form of a word based on a numeric value.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.plurality.html</link></decl><decl id="362" type="function"><name>unenclosed</name><desc>&lt;div&gt;&lt;p&gt;Removes paired preceding and trailing tokens around a string line.
    Assumes ASCII.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.unenclosed.html</link></decl><decl id="363" type="function"><name>unquoted</name><desc>&lt;div&gt;&lt;p&gt;Removes paired preceding and trailing double quotes, unquoting a word.
    Assumes ASCII.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.unquoted.html</link></decl><decl id="364" type="function"><name>unsinglequoted</name><desc>&lt;div&gt;&lt;p&gt;Removes paired preceding and trailing single quotes around a line.
    Assumes ASCII.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.unsinglequoted.html</link></decl><decl id="365" type="function"><name>stripSuffix</name><desc>&lt;div&gt;&lt;p&gt;Strips the supplied string from the end of a string.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.stripSuffix.html</link></decl><decl id="366" type="function"><name>tabs</name><desc>&lt;div&gt;&lt;p&gt;Returns a range of *spaces* equal to that of &lt;tt class=&quot;inline-code&quot;&gt;num&lt;/tt&gt; tabs (&lt;tt class=&quot;inline-code&quot;&gt;'\t'&lt;/tt&gt;).&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.tabs.html</link></decl><decl id="367" type="function"><name>indentInto</name><desc>&lt;div&gt;&lt;p&gt;Indents lines in a string into an output range sink with the supplied number
    of space-based tabs.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.indentInto.html</link></decl><decl id="368" type="function"><name>indent</name><desc>&lt;div&gt;&lt;p&gt;Indents lines in a string with the supplied number of space-based tabs.
    Returns a newly-allocated string.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.indent.html</link></decl><decl id="369" type="function"><name>strippedRight</name><desc>&lt;div&gt;&lt;p&gt;Returns a slice of the passed string with any trailing whitespace and/or
    linebreaks sliced off. Overload that implicitly strips &lt;tt class=&quot;inline-code&quot;&gt;&amp;quot; \n\r\t&amp;quot;&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.strippedRight.1.html</link></decl><decl id="370" type="function"><name>strippedRight</name><desc>&lt;div&gt;&lt;p&gt;Returns a slice of the passed string with any trailing passed characters.
    Implementation template capable of handling both individual characters and
    string of tokens to strip.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.strippedRight.2.html</link></decl><decl id="371" type="function"><name>strippedLeft</name><desc>&lt;div&gt;&lt;p&gt;Returns a slice of the passed string with any preceding whitespace and/or
    linebreaks sliced off. Overload that implicitly strips &lt;tt class=&quot;inline-code&quot;&gt;&amp;quot; \n\r\t&amp;quot;&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.strippedLeft.1.html</link></decl><decl id="372" type="function"><name>strippedLeft</name><desc>&lt;div&gt;&lt;p&gt;Returns a slice of the passed string with any preceding passed characters
    sliced off. Implementation capable of handling both individual characters
    and strings of tokens to strip.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.strippedLeft.2.html</link></decl><decl id="373" type="function"><name>stripped</name><desc>&lt;div&gt;&lt;p&gt;Returns a slice of the passed string with any preceding or trailing
    whitespace or linebreaks sliced off both ends. Overload that implicitly
    strips &lt;tt class=&quot;inline-code&quot;&gt;&amp;quot; \n\r\t&amp;quot;&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.stripped.1.html</link></decl><decl id="374" type="function"><name>stripped</name><desc>&lt;div&gt;&lt;p&gt;Returns a slice of the passed string with any preceding or trailing
    passed characters sliced off. Implementation template capable of handling both
    individual characters and strings of tokens to strip.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.stripped.2.html</link></decl><decl id="375" type="function"><name>encode64</name><desc>&lt;div&gt;&lt;p&gt;Base64-encodes a string.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.encode64.html</link></decl><decl id="376" type="function"><name>decode64</name><desc>&lt;div&gt;&lt;p&gt;Base64-decodes a string.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.decode64.html</link></decl><decl id="377" type="function"><name>splitLineAtPosition</name><desc>&lt;div&gt;&lt;p&gt;Splits a string with on boundary as delimited by a supplied separator, into
    one or more more lines not longer than the passed maximum length.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.splitLineAtPosition.html</link></decl><decl id="378" type="function"><name>escapeControlCharacters</name><desc>&lt;div&gt;&lt;p&gt;Replaces the control characters &lt;tt class=&quot;inline-code&quot;&gt;'\n'&lt;/tt&gt;, &lt;tt class=&quot;inline-code&quot;&gt;'\t'&lt;/tt&gt;, &lt;tt class=&quot;inline-code&quot;&gt;'\r'&lt;/tt&gt; and &lt;tt class=&quot;inline-code&quot;&gt;'\0'&lt;/tt&gt; in a string
    with the escaped &lt;tt class=&quot;inline-code&quot;&gt;&amp;quot;\\n&amp;quot;&lt;/tt&gt;, &lt;tt class=&quot;inline-code&quot;&gt;&amp;quot;\\t&amp;quot;&lt;/tt&gt;, &lt;tt class=&quot;inline-code&quot;&gt;&amp;quot;\\r&amp;quot;&lt;/tt&gt; and &lt;tt class=&quot;inline-code&quot;&gt;&amp;quot;\\0&amp;quot;&lt;/tt&gt;.
    Does not allocate a new string if there was nothing to escape.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.escapeControlCharacters.html</link></decl><decl id="379" type="function"><name>removeControlCharacters</name><desc>&lt;div&gt;&lt;p&gt;Removes the control characters &lt;tt class=&quot;inline-code&quot;&gt;'\n'&lt;/tt&gt;, &lt;tt class=&quot;inline-code&quot;&gt;'\t'&lt;/tt&gt;, &lt;tt class=&quot;inline-code&quot;&gt;'\r'&lt;/tt&gt; and &lt;tt class=&quot;inline-code&quot;&gt;'\0'&lt;/tt&gt; from a string.
    Does not allocate a new string if there was nothing to remove.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.removeControlCharacters.html</link></decl><decl id="380" type="enum"><name>SplitResults</name><desc>&lt;div&gt;&lt;p&gt;The result of a call to &lt;a class=&quot;xref&quot; href=&quot;lu.string.splitInto.2.html&quot;&gt;splitInto&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.SplitResults.html</link></decl><decl id="381" type="function"><name>splitInto</name><desc>&lt;div&gt;&lt;p&gt;Splits a string by a passed separator and assigns the delimited words to the
    passed ref strings.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.splitInto.1.html</link></decl><decl id="382" type="function"><name>splitInto</name><desc>&lt;div&gt;&lt;p&gt;Splits a string by a passed separator and assign the delimited words to the
    passed ref strings. Overload that stores overflow strings into a passed array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.splitInto.2.html</link></decl><decl id="383" type="function"><name>splitWithQuotes</name><desc>&lt;div&gt;&lt;p&gt;Splits a string into an array of strings by whitespace, but honours quotes.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.splitWithQuotes.html</link></decl><decl id="384" type="function"><name>replaceFromAA</name><desc>&lt;div&gt;&lt;p&gt;Replaces space-separated words that begin with a token character in a
    string that match keys in a supplied associative array.
    The associative array values must be of some callable type of function or
    delegate returning strings.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.string.replaceFromAA.html</link></decl></decl><decl id="385" type="module"><name>lu.container</name><desc>&lt;div&gt;&lt;p&gt;Containers of varying quality.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.html</link><decl id="386" type="struct"><name>Buffer</name><desc>&lt;div&gt;&lt;p&gt;Simple buffer/queue for storing and fetching items of any type &lt;tt class=&quot;inline-code&quot;&gt;T&lt;/tt&gt;.
    Does not use manual memory allocation.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.html</link><decl id="387" type="manifest constant"><name>growthFactor</name><desc>&lt;div&gt;&lt;p&gt;By how much to grow the buffer when we reach the end of it.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.growthFactor.html</link></decl><decl id="388" type="variable"><name>buf</name><desc>&lt;div&gt;&lt;p&gt;Internal buffer dynamic array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.buf.1.html</link></decl><decl id="389" type="variable"><name>bufferSize</name><desc>&lt;div&gt;&lt;p&gt;Variable buffer size.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.bufferSize.1.html</link></decl><decl id="390" type="variable"><name>buf</name><desc>&lt;div&gt;&lt;p&gt;Internal buffer static array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.buf.2.html</link></decl><decl id="391" type="alias"><name>bufferSize</name><desc>&lt;div&gt;&lt;p&gt;Static buffer size.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.bufferSize.2.html</link></decl><decl id="392" type="variable"><name>pos</name><desc>&lt;div&gt;&lt;p&gt;Current position in the array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.pos.html</link></decl><decl id="393" type="variable"><name>end</name><desc>&lt;div&gt;&lt;p&gt;Position of last entry in the array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.end.html</link></decl><decl id="394" type="function"><name>put</name><desc>&lt;div&gt;&lt;p&gt;Append an item to the end of the buffer.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.put.1.html</link></decl><decl id="395" type="function"><name>put</name><desc>&lt;div&gt;&lt;p&gt;Append an item to the end of the buffer.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.put.2.html</link></decl><decl id="396" type="function"><name>reserve</name><desc>&lt;div&gt;&lt;p&gt;Reserves enough room for the specified number of elements. If there
            is already enough room, nothing is done. Otherwise the buffer is grown.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.reserve.html</link></decl><decl id="397" type="function"><name>opOpAssign</name><desc>&lt;div&gt;&lt;p&gt;Implements &lt;tt class=&quot;inline-code&quot;&gt;buf ~= someT&lt;/tt&gt; (appending) by wrapping &lt;tt class=&quot;inline-code&quot;&gt;put&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.opOpAssign.html</link></decl><decl id="398" type="function"><name>front</name><desc>&lt;div&gt;&lt;p&gt;Fetches the item at the current position of the buffer.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.front.html</link></decl><decl id="399" type="function"><name>popFront</name><desc>&lt;div&gt;&lt;p&gt;Advances the current position to the next item in the buffer.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.popFront.html</link></decl><decl id="400" type="function"><name>length</name><desc>&lt;div&gt;&lt;p&gt;Returns what amounts to the current length of the buffer; the distance
        between the current position &lt;tt class=&quot;inline-code&quot;&gt;pos&lt;/tt&gt; and the last element &lt;tt class=&quot;inline-code&quot;&gt;end&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.length.html</link></decl><decl id="401" type="function"><name>empty</name><desc>&lt;div&gt;&lt;p&gt;Returns whether or not the container is considered empty.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.empty.html</link></decl><decl id="402" type="function"><name>reset</name><desc>&lt;div&gt;&lt;p&gt;Resets the array positions, effectively soft-emptying the buffer.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.reset.html</link></decl><decl id="403" type="function"><name>clear</name><desc>&lt;div&gt;&lt;p&gt;Zeroes out the buffer's elements, getting rid of old contents.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.Buffer.clear.html</link></decl></decl><decl id="404" type="struct"><name>CircularBuffer</name><desc>&lt;div&gt;&lt;p&gt;Simple circular-ish buffer for storing items of type &lt;tt class=&quot;inline-code&quot;&gt;T&lt;/tt&gt; that discards elements
    when the maximum size is reached. Does not use manual memory allocation.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.html</link><decl id="405" type="variable"><name>buf</name><desc>&lt;div&gt;&lt;p&gt;Internal buffer dynamic array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.buf.1.html</link></decl><decl id="406" type="variable"><name>buf</name><desc>&lt;div&gt;&lt;p&gt;Internal buffer static array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.buf.2.html</link></decl><decl id="407" type="variable"><name>head</name><desc>&lt;div&gt;&lt;p&gt;Head position in the internal buffer.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.head.html</link></decl><decl id="408" type="variable"><name>tail</name><desc>&lt;div&gt;&lt;p&gt;Tail position in the internal buffer.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.tail.html</link></decl><decl id="409" type="variable"><name>caughtUp</name><desc>&lt;div&gt;&lt;p&gt;Whether or not &lt;a class=&quot;xref&quot; href=&quot;lu.container.CircularBuffer.head.html&quot;&gt;head&lt;/a&gt; and &lt;a class=&quot;xref&quot; href=&quot;lu.container.CircularBuffer.tail.html&quot;&gt;tail&lt;/a&gt; point to the same position in the
        context of a circular array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.caughtUp.html</link></decl><decl id="410" type="variable"><name>initialised</name><desc>&lt;div&gt;&lt;p&gt;Whether or not at least one element has been added.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.initialised.html</link></decl><decl id="411" type="function"><name>front</name><desc>&lt;div&gt;&lt;p&gt;Returns the front element.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.front.html</link></decl><decl id="412" type="function"><name>put</name><desc>&lt;div&gt;&lt;p&gt;Append an item to the buffer.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.put.html</link></decl><decl id="413" type="function"><name>popFront</name><desc>&lt;div&gt;&lt;p&gt;Advances the current position to the next item in the buffer.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.popFront.html</link></decl><decl id="414" type="function"><name>resize</name><desc>&lt;div&gt;&lt;p&gt;Resizes the internal buffer to a specified size.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.resize.html</link></decl><decl id="415" type="function"><name>opOpAssign</name><desc>&lt;div&gt;&lt;p&gt;Implements &lt;tt class=&quot;inline-code&quot;&gt;buf ~= someT&lt;/tt&gt; (appending) by wrapping &lt;tt class=&quot;inline-code&quot;&gt;put&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.opOpAssign.html</link></decl><decl id="416" type="function"><name>size</name><desc>&lt;div&gt;&lt;p&gt;Returns the size of the internal buffer.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.size.html</link></decl><decl id="417" type="function"><name>empty</name><desc>&lt;div&gt;&lt;p&gt;Returns whether or not the container is considered empty.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.empty.html</link></decl><decl id="418" type="function"><name>save</name><desc>&lt;div&gt;&lt;p&gt;Implements Range &lt;tt class=&quot;inline-code&quot;&gt;save&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.save.html</link></decl><decl id="419" type="function"><name>dup</name><desc>&lt;div&gt;&lt;p&gt;Makes a deep(er) duplicate of the container.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.dup.html</link></decl><decl id="420" type="function"><name>reset</name><desc>&lt;div&gt;&lt;p&gt;Resets the buffer pointers but doesn't clear the contents.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.reset.html</link></decl><decl id="421" type="function"><name>clear</name><desc>&lt;div&gt;&lt;p&gt;Zeroes out the buffer's elements, getting rid of old contents.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.CircularBuffer.clear.html</link></decl></decl><decl id="422" type="struct"><name>RehashingAA</name><desc>&lt;div&gt;&lt;p&gt;A wrapper around a native associative array that you can controllably set to
    automatically rehash as entries are added.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.html</link><decl id="423" type="variable"><name>aa</name><desc>&lt;div&gt;&lt;p&gt;Internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.aa.html</link></decl><decl id="424" type="variable"><name>_numRehashes</name><desc>&lt;div&gt;&lt;p&gt;The number of times this instance has rehashed itself. Private value.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA._numRehashes.html</link></decl><decl id="425" type="variable"><name>_newKeysSinceLastRehash</name><desc>&lt;div&gt;&lt;p&gt;The number of new entries that has been added since the last rehash. Private value.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA._newKeysSinceLastRehash.html</link></decl><decl id="426" type="variable"><name>_lengthAtLastRehash</name><desc>&lt;div&gt;&lt;p&gt;The number of keys (and length of the array) when the last rehash took place.
        Private value.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA._lengthAtLastRehash.html</link></decl><decl id="427" type="variable"><name>minimumNeededForRehash</name><desc>&lt;div&gt;&lt;p&gt;The minimum number of additions needed before the first rehash takes place.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.minimumNeededForRehash.html</link></decl><decl id="428" type="variable"><name>rehashThresholdMultiplier</name><desc>&lt;div&gt;&lt;p&gt;The modifier by how much more entries must be added before another rehash
        takes place, with regards to the current &lt;a class=&quot;xref&quot; href=&quot;lu.container.RehashingAA.aa.html&quot;&gt;aa&lt;/a&gt; length.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.rehashThresholdMultiplier.html</link></decl><decl id="429" type="function"><name>opIndexAssign</name><desc>&lt;div&gt;&lt;p&gt;Assigns a value into the internal associative array. If it created a new
        entry, then call &lt;a class=&quot;xref&quot; href=&quot;lu.container.RehashingAA.maybeRehash.html&quot;&gt;maybeRehash&lt;/a&gt; to bump the internal counter and maybe rehash.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.opIndexAssign.html</link></decl><decl id="430" type="function"><name>opIndex</name><desc>&lt;div&gt;&lt;p&gt;Returns the value for the passed key in the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.opIndex.html</link></decl><decl id="431" type="function"><name>opIndexUnary</name><desc>&lt;div&gt;&lt;p&gt;Performs a unary operation on a value in the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.opIndexUnary.html</link></decl><decl id="432" type="function"><name>opAssign</name><desc>&lt;div&gt;&lt;p&gt;Inherit a native associative array into &lt;a class=&quot;xref&quot; href=&quot;lu.container.RehashingAA.aa.html&quot;&gt;aa&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.opAssign.html</link></decl><decl id="433" type="function"><name>opIndexOpAssign</name><desc>&lt;div&gt;&lt;p&gt;Performs an assignment operation on a value in the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.opIndexOpAssign.html</link></decl><decl id="434" type="function"><name>opCast</name><desc>&lt;div&gt;&lt;p&gt;Allows for casting this into the base associative array type.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.opCast.html</link></decl><decl id="435" type="function"><name>aaOf</name><desc>&lt;div&gt;&lt;p&gt;Returns the internal associative array, for when the wrapper is insufficient.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.aaOf.html</link></decl><decl id="436" type="function"><name>remove</name><desc>&lt;div&gt;&lt;p&gt;Removes a key from the &lt;a class=&quot;xref&quot; href=&quot;lu.container.RehashingAA.aa.html&quot;&gt;aa&lt;/a&gt; associative array by merely
        invoking &lt;tt class=&quot;inline-code&quot;&gt;.remove&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.remove.html</link></decl><decl id="437" type="function"><name>maybeRehash</name><desc>&lt;div&gt;&lt;p&gt;Bumps the internal counter of new keys since the last rehash, and depending
        on the resulting value of it, maybe rehashes.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.maybeRehash.html</link></decl><decl id="438" type="function"><name>clear</name><desc>&lt;div&gt;&lt;p&gt;Clears the internal associative array and all counters.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.clear.html</link></decl><decl id="439" type="function"><name>rehash</name><desc>&lt;div&gt;&lt;p&gt;Rehashes the internal associative array, bumping the rehash counter and
        zeroing the keys-added counter. Additionally invokes the &lt;a class=&quot;xref&quot; href=&quot;lu.container.RehashingAA.onRehashDg.html&quot;&gt;onRehashDg&lt;/a&gt; delegate.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.rehash.html</link></decl><decl id="440" type="function"><name>numRehashes</name><desc>&lt;div&gt;&lt;p&gt;The number of times this instance has rehashed itself. Accessor.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.numRehashes.html</link></decl><decl id="441" type="function"><name>newKeysSinceLastRehash</name><desc>&lt;div&gt;&lt;p&gt;The number of new entries that has been added since the last rehash. Accessor.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.newKeysSinceLastRehash.html</link></decl><decl id="442" type="function"><name>opBinaryRight</name><desc>&lt;div&gt;&lt;p&gt;Wraps &lt;tt class=&quot;inline-code&quot;&gt;key in aa&lt;/tt&gt; to the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.opBinaryRight.html</link></decl><decl id="443" type="function"><name>byValue</name><desc>&lt;div&gt;&lt;p&gt;Wraps the internal associative array's &lt;tt class=&quot;inline-code&quot;&gt;byValue&lt;/tt&gt; function.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.byValue.html</link></decl><decl id="444" type="function"><name>byKey</name><desc>&lt;div&gt;&lt;p&gt;Wraps the internal associative array's &lt;tt class=&quot;inline-code&quot;&gt;byKey&lt;/tt&gt; function.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.byKey.html</link></decl><decl id="445" type="function"><name>values</name><desc>&lt;div&gt;&lt;p&gt;Wraps the internal associative array's &lt;tt class=&quot;inline-code&quot;&gt;values&lt;/tt&gt; function.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.values.html</link></decl><decl id="446" type="function"><name>keys</name><desc>&lt;div&gt;&lt;p&gt;Wraps the internal associative array's &lt;tt class=&quot;inline-code&quot;&gt;keys&lt;/tt&gt; function.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.keys.html</link></decl><decl id="447" type="function"><name>byKeyValue</name><desc>&lt;div&gt;&lt;p&gt;Wraps the internal associative array's &lt;tt class=&quot;inline-code&quot;&gt;byKeyValue&lt;/tt&gt; function.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.byKeyValue.html</link></decl><decl id="448" type="function"><name>length</name><desc>&lt;div&gt;&lt;p&gt;Returns the length of the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.length.html</link></decl><decl id="449" type="function"><name>dup</name><desc>&lt;div&gt;&lt;p&gt;Duplicates this. Explicitly copies the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.dup.html</link></decl><decl id="450" type="function"><name>require</name><desc>&lt;div&gt;&lt;p&gt;Returns the value for the key &lt;tt class=&quot;inline-code&quot;&gt;key&lt;/tt&gt;, inserting &lt;tt class=&quot;inline-code&quot;&gt;value&lt;/tt&gt; lazily if it is not present.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.require.html</link></decl><decl id="451" type="function"><name>get</name><desc>&lt;div&gt;&lt;p&gt;Retrieves the value for the key &lt;tt class=&quot;inline-code&quot;&gt;key&lt;/tt&gt;, or returns the default &lt;tt class=&quot;inline-code&quot;&gt;value&lt;/tt&gt;
        if there was none.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.get.html</link></decl><decl id="452" type="function"><name>uniqueKey</name><desc>&lt;div&gt;&lt;p&gt;Reserves a unique key in the associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.uniqueKey.html</link></decl><decl id="453" type="function"><name>update</name><desc>&lt;div&gt;&lt;p&gt;Updates the value for the key &lt;tt class=&quot;inline-code&quot;&gt;key&lt;/tt&gt; in the internal associative array,
        invoking the first of the passed delegate to insert a new value if it
        doesn't exist, or the second selegate to modify it in place if it does.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.update.html</link></decl><decl id="454" type="function"><name>opEquals</name><desc>&lt;div&gt;&lt;p&gt;Implements &lt;tt class=&quot;inline-code&quot;&gt;opEquals&lt;/tt&gt; for this type, comparing the internal associative
        array with that of another &lt;tt class=&quot;inline-code&quot;&gt;RehashingAA&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.opEquals.1.html</link></decl><decl id="455" type="function"><name>opEquals</name><desc>&lt;div&gt;&lt;p&gt;Implements &lt;tt class=&quot;inline-code&quot;&gt;opEquals&lt;/tt&gt; for this type, comparing the internal associative
        array with a different one.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.opEquals.2.html</link></decl><decl id="456" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Constructor.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.this.html</link></decl><decl id="457" type="variable"><name>onRehashDg</name><desc>&lt;div&gt;&lt;p&gt;Delegate called when rehashing takes place.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.RehashingAA.onRehashDg.html</link></decl></decl><decl id="458" type="function"><name>rehashingAA</name><desc>&lt;div&gt;&lt;p&gt;Convenience helper to instantiate a &lt;a class=&quot;xref&quot; href=&quot;lu.container.RehashingAA.html&quot;&gt;RehashingAA&lt;/a&gt; instance with an
    existing associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.rehashingAA.html</link></decl><decl id="459" type="struct"><name>MutexedAA</name><desc>&lt;div&gt;&lt;p&gt;An associative array and a &lt;a class=&quot;xref&quot; href=&quot;core.sync.mutex.Mutex.html&quot;&gt;Mutex&lt;/a&gt;. Wraps associative
    array operations in mutex locks.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.html</link><decl id="460" type="variable"><name>mutex</name><desc>&lt;div&gt;&lt;p&gt;&lt;a class=&quot;xref&quot; href=&quot;core.sync.mutex.Mutex.html&quot;&gt;Mutex&lt;/a&gt; to lock the associative array with.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.mutex.html</link></decl><decl id="461" type="variable"><name>aa</name><desc>&lt;div&gt;&lt;p&gt;The internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.aa.html</link></decl><decl id="462" type="function"><name>setup</name><desc>&lt;div&gt;&lt;p&gt;Sets up this instance. Does nothing if it has already been set up.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.setup.html</link></decl><decl id="463" type="function"><name>aaOf</name><desc>&lt;div&gt;&lt;p&gt;Returns the internal associative array, for when the wrapper is insufficient.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.aaOf.html</link></decl><decl id="464" type="function"><name>isReady</name><desc>&lt;div&gt;&lt;p&gt;Returns whether or not this instance has been set up.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.isReady.html</link></decl><decl id="465" type="function"><name>opIndexAssign</name><desc>&lt;div&gt;&lt;p&gt;&lt;tt class=&quot;inline-code&quot;&gt;aa[key] = value&lt;/tt&gt; array assign operation, wrapped in a mutex lock.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.opIndexAssign.html</link></decl><decl id="466" type="function"><name>opIndex</name><desc>&lt;div&gt;&lt;p&gt;&lt;tt class=&quot;inline-code&quot;&gt;aa[key]&lt;/tt&gt; array retrieve operation, wrapped in a mutex lock.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.opIndex.html</link></decl><decl id="467" type="function"><name>has</name><desc>&lt;div&gt;&lt;p&gt;Returns whether or not the passed key is in the associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.has.html</link></decl><decl id="468" type="function"><name>remove</name><desc>&lt;div&gt;&lt;p&gt;&lt;tt class=&quot;inline-code&quot;&gt;aa.remove(key)&lt;/tt&gt; array operation, wrapped in a mutex lock.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.remove.html</link></decl><decl id="469" type="function"><name>uniqueKey</name><desc>&lt;div&gt;&lt;p&gt;Reserves a unique key in the associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.uniqueKey.html</link></decl><decl id="470" type="function"><name>opEquals</name><desc>&lt;div&gt;&lt;p&gt;Implements &lt;tt class=&quot;inline-code&quot;&gt;opEquals&lt;/tt&gt; for this type, comparing the internal associative
        array with that of another &lt;tt class=&quot;inline-code&quot;&gt;MutexedAA&lt;/tt&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.opEquals.1.html</link></decl><decl id="471" type="function"><name>opEquals</name><desc>&lt;div&gt;&lt;p&gt;Implements &lt;tt class=&quot;inline-code&quot;&gt;opEquals&lt;/tt&gt; for this type, comparing the internal associative
        array with a different one.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.opEquals.2.html</link></decl><decl id="472" type="function"><name>rehash</name><desc>&lt;div&gt;&lt;p&gt;Rehashes the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.rehash.html</link></decl><decl id="473" type="function"><name>clear</name><desc>&lt;div&gt;&lt;p&gt;Clears the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.clear.html</link></decl><decl id="474" type="function"><name>length</name><desc>&lt;div&gt;&lt;p&gt;Returns the length of the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.length.html</link></decl><decl id="475" type="function"><name>require</name><desc>&lt;div&gt;&lt;p&gt;Returns the value for the key &lt;tt class=&quot;inline-code&quot;&gt;key&lt;/tt&gt;, inserting &lt;tt class=&quot;inline-code&quot;&gt;value&lt;/tt&gt; lazily if it is not present.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.require.html</link></decl><decl id="476" type="function"><name>keys</name><desc>&lt;div&gt;&lt;p&gt;Returns a new dynamic array of all the keys in the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.keys.html</link></decl><decl id="477" type="function"><name>values</name><desc>&lt;div&gt;&lt;p&gt;Returns a new dynamic array of all the values in the internal associative array.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.values.html</link></decl><decl id="478" type="function"><name>get</name><desc>&lt;div&gt;&lt;p&gt;Retrieves the value for the key &lt;tt class=&quot;inline-code&quot;&gt;key&lt;/tt&gt;, or returns the default &lt;tt class=&quot;inline-code&quot;&gt;value&lt;/tt&gt;
        if there was none.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.get.html</link></decl><decl id="479" type="function"><name>update</name><desc>&lt;div&gt;&lt;p&gt;Updates the value for the key &lt;tt class=&quot;inline-code&quot;&gt;key&lt;/tt&gt; in the internal associative array,
        invoking the first of the passed delegate to insert a new value if it
        doesn't exist, or the second selegate to modify it in place if it does.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.update.html</link></decl><decl id="480" type="function"><name>opIndexUnary</name><desc>&lt;div&gt;&lt;p&gt;Implements unary operations by mixin strings.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.opIndexUnary.html</link></decl><decl id="481" type="function"><name>opIndexOpAssign</name><desc>&lt;div&gt;&lt;p&gt;Implements index assign operations by mixin strings.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.MutexedAA.opIndexOpAssign.html</link></decl></decl><decl id="482" type="function"><name>mutexedAA</name><desc>&lt;div&gt;&lt;p&gt;Convenience function to create and setup a &lt;a class=&quot;xref&quot; href=&quot;lu.container.MutexedAA.html&quot;&gt;MutexedAA&lt;/a&gt; instance in one go.
    &lt;a class=&quot;xref&quot; href=&quot;lu.container.MutexedAA.setup.html&quot;&gt;MutexedAA.setup&lt;/a&gt; need as such not be called.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.mutexedAA.1.html</link></decl><decl id="483" type="function"><name>mutexedAA</name><desc>&lt;div&gt;&lt;p&gt;Convenience function to create and setup a &lt;a class=&quot;xref&quot; href=&quot;lu.container.MutexedAA.html&quot;&gt;MutexedAA&lt;/a&gt; instance.
    Overload that inherits an original associative array, or optionally duplicates it.
    Infers the types to instantiate the &lt;a class=&quot;xref&quot; href=&quot;lu.container.MutexedAA.html&quot;&gt;MutexedAA&lt;/a&gt; with from the AA passed.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.container.mutexedAA.2.html</link></decl></decl><decl id="484" type="module"><name>lu.json</name><desc>&lt;div&gt;&lt;p&gt;Simple wrappers around Phobos &lt;a class=&quot;xref&quot; href=&quot;std.json.html&quot;&gt;std.json&lt;/a&gt;. This is *not* a replacement for it.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.html</link><decl id="485" type="struct"><name>JSONStorage</name><desc>&lt;div&gt;&lt;p&gt;A wrapped &lt;a class=&quot;xref&quot; href=&quot;std.json.JSONValue.html&quot;&gt;JSONValue&lt;/a&gt; with helper functions.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.JSONStorage.html</link><decl id="486" type="variable"><name>storage</name><desc>&lt;div&gt;&lt;p&gt;The underlying &lt;a class=&quot;xref&quot; href=&quot;std.json.JSONValue.html&quot;&gt;JSONValue&lt;/a&gt; storage of this &lt;a class=&quot;xref&quot; href=&quot;lu.json.JSONStorage.html&quot;&gt;JSONStorage&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.JSONStorage.storage.html</link></decl><decl id="487" type="enum"><name>KeyOrderStrategy</name><desc>&lt;div&gt;&lt;p&gt;Strategy with which to sort object-type JSON keys when we format/serialise
        the stored &lt;a class=&quot;xref&quot; href=&quot;lu.json.JSONStorage.storage.html&quot;&gt;storage&lt;/a&gt; to string.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.JSONStorage.KeyOrderStrategy.html</link></decl><decl id="488" type="function"><name>reset</name><desc>&lt;div&gt;&lt;p&gt;Initialises and clears the &lt;a class=&quot;xref&quot; href=&quot;std.json.JSONValue.html&quot;&gt;JSONValue&lt;/a&gt;, preparing
        it for object storage.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.JSONStorage.reset.html</link></decl><decl id="489" type="function"><name>load</name><desc>&lt;div&gt;&lt;p&gt;Loads JSON from disk.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.JSONStorage.load.html</link></decl><decl id="490" type="function"><name>save</name><desc>&lt;div&gt;&lt;p&gt;Saves the JSON storage to disk. Formatting is done as specified by the
        passed &lt;a class=&quot;xref&quot; href=&quot;lu.json.JSONStorage.KeyOrderStrategy.html&quot;&gt;KeyOrderStrategy&lt;/a&gt; argument.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.JSONStorage.save.html</link></decl><decl id="491" type="function"><name>serialiseInto</name><desc>&lt;div&gt;&lt;p&gt;Formats an object-type JSON storage into an output range sink.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.JSONStorage.serialiseInto.1.html</link></decl><decl id="492" type="function"><name>serialiseInto</name><desc>&lt;div&gt;&lt;p&gt;Formats an object-type JSON storage into an output range sink.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.JSONStorage.serialiseInto.2.html</link></decl></decl><decl id="493" type="function"><name>populateFromJSON</name><desc>&lt;div&gt;&lt;p&gt;Recursively populates a passed associative or dynamic array with the
    contents of a &lt;a class=&quot;xref&quot; href=&quot;std.json.JSONValue.html&quot;&gt;JSONValue&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.populateFromJSON.html</link></decl><decl id="494" type="function"><name>safelyGet</name><desc>&lt;div&gt;&lt;p&gt;Fetches a value from a &lt;a class=&quot;xref&quot; href=&quot;std.json.JSONValue.html&quot;&gt;JSONValue&lt;/a&gt;, or returns a fallback
    value if the key doesn't exist in the object.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.safelyGet.html</link></decl><decl id="495" type="alias"><name>getOrFallback</name><desc>&lt;div&gt;&lt;p&gt;Compatibility alias to &lt;a class=&quot;xref&quot; href=&quot;lu.json.safelyGet.html&quot;&gt;safelyGet&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.json.getOrFallback.html</link></decl></decl><decl id="496" type="module"><name>lu.meld</name><desc>&lt;div&gt;&lt;p&gt;This module contains the &lt;a class=&quot;xref&quot; href=&quot;lu.meld.meldInto.3.html&quot;&gt;meldInto&lt;/a&gt; functions; functions that take two
    structs or classes of the same type and combine them, creating a resulting
    object with the union of the members of both parents. Array and associative
    array variants exist too.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.meld.html</link><decl id="497" type="enum"><name>MeldingStrategy</name><desc>&lt;div&gt;&lt;p&gt;To what extent a source should overwrite a target when melding.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.meld.MeldingStrategy.html</link></decl><decl id="498" type="function"><name>meldInto</name><desc>&lt;div&gt;&lt;p&gt;Takes two structs or classes of the same type and melds them together,
    making the members of the resulting aggregate a union of the two.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.meld.meldInto.1.html</link></decl><decl id="499" type="function"><name>meldInto</name><desc>&lt;div&gt;&lt;p&gt;Takes two arrays and melds them together, making a union of the two.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.meld.meldInto.2.html</link></decl><decl id="500" type="function"><name>meldInto</name><desc>&lt;div&gt;&lt;p&gt;Takes two associative arrays and melds them together, making a union of the two.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.meld.meldInto.3.html</link></decl></decl><decl id="501" type="module"><name>lu.conv</name><desc>&lt;div&gt;&lt;p&gt;This module contains functions that in one way or another converts its
    arguments into something else.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.conv.html</link><decl id="502" type="template"><name>Enum</name><desc>&lt;div&gt;&lt;p&gt;Template housing optimised functions to get the string name of an enum
    member, or the enum member of a name string.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.conv.Enum.html</link><decl id="503" type="function"><name>fromString</name><desc>&lt;div&gt;&lt;p&gt;Takes the member of an enum by string and returns the member of that name.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.conv.Enum.fromString.html</link></decl><decl id="504" type="function"><name>toString</name><desc>&lt;div&gt;&lt;p&gt;The inverse of &lt;a class=&quot;xref&quot; href=&quot;lu.conv.Enum.fromString.html&quot;&gt;fromString&lt;/a&gt;, this function takes an enum member value
        and returns its string identifier.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.conv.Enum.toString.html</link></decl></decl><decl id="505" type="function"><name>toString</name><desc>&lt;div&gt;&lt;p&gt;Convenience wrapper around &lt;a class=&quot;xref&quot; href=&quot;lu.conv.Enum.toString.html&quot;&gt;Enum.toString&lt;/a&gt; that infers the type
    to instantiate it with from the passed enum member.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.conv.toString.html</link></decl><decl id="506" type="alias"><name>enumToString</name><desc>&lt;div&gt;&lt;p&gt;Deprecated alias of &lt;a class=&quot;xref&quot; href=&quot;lu.conv.toString.html&quot;&gt;toString&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.conv.enumToString.html</link></decl><decl id="507" type="function"><name>numFromHex</name><desc>&lt;div&gt;&lt;p&gt;Returns the decimal value of a hex number in string form.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.conv.numFromHex.html</link></decl><decl id="508" type="function"><name>rgbFromHex</name><desc>&lt;div&gt;&lt;p&gt;Convenience wrapper that takes a hex string and populates a Voldemort
    struct with its integer RR, GG and BB components.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.conv.rgbFromHex.html</link></decl><decl id="509" type="function"><name>toAlphaInto</name><desc>&lt;div&gt;&lt;p&gt;Translates an integer into an alphanumeric string.
    Overload that takes an output range sink.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.conv.toAlphaInto.html</link></decl><decl id="510" type="function"><name>toAlpha</name><desc>&lt;div&gt;&lt;p&gt;Translates an integer into an alphanumeric string.
    Overload that returns the string.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.conv.toAlpha.html</link></decl></decl><decl id="511" type="module"><name>lu.uda</name><desc>&lt;div&gt;&lt;p&gt;Common user-defined attributes (UDAs).&lt;/p&gt;&lt;/div&gt;</desc><link>lu.uda.html</link><decl id="512" type="enum"><name>Unserialisable</name><desc>&lt;div&gt;&lt;p&gt;UDA conveying that the annotated member cannot (or should not) be serialised.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.uda.Unserialisable.html</link></decl><decl id="513" type="struct"><name>Separator</name><desc>&lt;div&gt;&lt;p&gt;UDA conveying that the annotated array should have this token as separator
    when formatted to a string.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.uda.Separator.html</link><decl id="514" type="variable"><name>token</name><desc>&lt;div&gt;&lt;p&gt;Separator, can be more than one character.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.uda.Separator.token.html</link></decl></decl><decl id="515" type="enum"><name>Hidden</name><desc>&lt;div&gt;&lt;p&gt;UDA conveying that the annotated member contains sensitive information and
    should not be printed in clear text; e.g. passwords.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.uda.Hidden.html</link></decl><decl id="516" type="enum"><name>CannotContainComments</name><desc>&lt;div&gt;&lt;p&gt;UDA conveying that the annotated member may contain characters that would
    otherwise indicate a comment, and that this should be ignored.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.uda.CannotContainComments.html</link></decl><decl id="517" type="enum"><name>Quoted</name><desc>&lt;div&gt;&lt;p&gt;UDA conveying that the annotated member's value must be quoted when serialised.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.uda.Quoted.html</link></decl><decl id="518" type="enum"><name>Unmeldable</name><desc>&lt;div&gt;&lt;p&gt;UDA conveying that the annotated member's value cannot or should not be melded.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.uda.Unmeldable.html</link></decl></decl><decl id="519" type="module"><name>lu.typecons</name><desc>&lt;div&gt;&lt;p&gt;Type constructors.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.typecons.html</link><decl id="520" type="mixin template"><name>OpDispatcher</name><desc>&lt;div&gt;&lt;p&gt;Mixin template generating an &lt;tt class=&quot;inline-code&quot;&gt;opDispatch&lt;/tt&gt; redirecting calls to members whose
    names match the passed variable string but with a given token string in
    the front or at the end of the name.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.typecons.OpDispatcher.html</link><decl id="521" type="function"><name>opDispatch</name><desc>&lt;div&gt;&lt;p&gt;Mutator.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.typecons.OpDispatcher.opDispatch.1.html</link></decl><decl id="522" type="function"><name>opDispatch</name><desc>&lt;div&gt;&lt;p&gt;Accessor.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.typecons.OpDispatcher.opDispatch.2.html</link></decl></decl><decl id="523" type="mixin template"><name>UnderscoreOpDispatcher</name><desc>&lt;div&gt;&lt;p&gt;Mixin template generating an &lt;tt class=&quot;inline-code&quot;&gt;opDispatch&lt;/tt&gt; redirecting calls to members whose
    names match the passed variable string but with an underscore prepended to
    the name.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.typecons.UnderscoreOpDispatcher.html</link></decl></decl><decl id="524" type="module"><name>lu.serialisation</name><desc>&lt;div&gt;&lt;p&gt;Various functions related to serialising and deserialising structs into/from
    configuration file-y files.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.html</link><decl id="525" type="function"><name>serialise</name><desc>&lt;div&gt;&lt;p&gt;Convenience function to call &lt;a class=&quot;xref&quot; href=&quot;lu.serialisation.serialise.2.html&quot;&gt;serialise&lt;/a&gt; on several objects.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.serialise.1.html</link></decl><decl id="526" type="function"><name>serialise</name><desc>&lt;div&gt;&lt;p&gt;Serialises the fields of an object into a configuration file-y format.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.serialise.2.html</link></decl><decl id="527" type="struct"><name>SerialisationUDAs</name><desc>&lt;div&gt;&lt;p&gt;Summary of UDAs that an array to be serialised is annotated with.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.SerialisationUDAs.html</link><decl id="528" type="variable"><name>unserialisable</name><desc>&lt;div&gt;&lt;p&gt;The value of the &lt;a class=&quot;xref&quot; href=&quot;lu.uda.Separator.html&quot;&gt;Separator&lt;/a&gt; UDA the array was
        annotated with.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.SerialisationUDAs.unserialisable.html</link></decl><decl id="529" type="variable"><name>separator</name><desc>&lt;div&gt;&lt;p&gt;The value of the &lt;a class=&quot;xref&quot; href=&quot;lu.uda.Separator.html&quot;&gt;Separator&lt;/a&gt; UDA the array was
        annotated with.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.SerialisationUDAs.separator.html</link></decl><decl id="530" type="variable"><name>escapedSeparator</name><desc>&lt;div&gt;&lt;p&gt;The escaped form of &lt;a class=&quot;xref&quot; href=&quot;lu.serialisation.SerialisationUDAs.separator.html&quot;&gt;separator&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.SerialisationUDAs.escapedSeparator.html</link></decl><decl id="531" type="variable"><name>arrayPattern</name><desc>&lt;div&gt;&lt;p&gt;The &lt;a class=&quot;xref&quot; href=&quot;std.format.format.html&quot;&gt;format&lt;/a&gt; pattern used to format the array this struct
        refers to. This is separator-specific.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.SerialisationUDAs.arrayPattern.html</link></decl></decl><decl id="532" type="function"><name>serialiseArrayImpl</name><desc>&lt;div&gt;&lt;p&gt;Serialises a non-string array into a single row. To be used when serialising
    an aggregate with &lt;a class=&quot;xref&quot; href=&quot;lu.serialisation.serialise.2.html&quot;&gt;serialise&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.serialiseArrayImpl.html</link></decl><decl id="533" type="function"><name>deserialise</name><desc>&lt;div&gt;&lt;p&gt;Takes an input range containing serialised entry-value text and applies the
    contents therein to one or more passed struct/class objects.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.deserialise.html</link></decl><decl id="534" type="function"><name>justifiedEntryValueText</name><desc>&lt;div&gt;&lt;p&gt;Takes an unformatted string of serialised entry-value text and justifies it
    into two neat columns.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.justifiedEntryValueText.html</link></decl><decl id="535" type="class"><name>DeserialisationException</name><desc>&lt;div&gt;&lt;p&gt;Exception, to be thrown when the specified serialised text could not be
    parsed, for whatever reason.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.DeserialisationException.html</link><decl id="536" type="constructor"><name>this</name><desc>&lt;div&gt;&lt;p&gt;Creates a new &lt;a class=&quot;xref&quot; href=&quot;lu.serialisation.DeserialisationException.html&quot;&gt;DeserialisationException&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.DeserialisationException.this.html</link></decl></decl><decl id="537" type="function"><name>splitEntryValue</name><desc>&lt;div&gt;&lt;p&gt;Splits a line into an entry and a value component.&lt;/p&gt;&lt;/div&gt;</desc><link>lu.serialisation.splitEntryValue.html</link></decl></decl></listing>
<index>
</index>
</adrdox>
</script>
<script src="search-docs.js"></script>
</body></html>
